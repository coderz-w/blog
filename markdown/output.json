{
  "postDataMap": {
    "first": {
      "authors": [
        "zhw"
      ],
      "title": "建站",
      "tag": "生活",
      "path": "first",
      "rawFilePath": "./first.md",
      "coverImage": "https://upload-bbs.miyoushe.com/upload/2024/07/27/75276539/98580c852764d70e5a9597aa7678f131_2245446554692880272.jpg",
      "text": "记录一下建站的第一天,也许开心到爆炸.\r\n![建站图片](https://upload-bbs.miyoushe.com/upload/2024/07/27/75276539/98580c852764d70e5a9597aa7678f131_2245446554692880272.jpg)\r\n![建站图片](https://upload-bbs.miyoushe.com/upload/2024/03/20/285532152/757fa74f8b38fdfab0bd1b653a69af4d_6553329811603610700.gif)\r\n",
      "count": "268",
      "readingTime": "1 ",
      "imageUrls": [
        "https://upload-bbs.miyoushe.com/upload/2024/07/27/75276539/98580c852764d70e5a9597aa7678f131_2245446554692880272.jpg",
        "https://upload-bbs.miyoushe.com/upload/2024/03/20/285532152/757fa74f8b38fdfab0bd1b653a69af4d_6553329811603610700.gif"
      ],
      "createdAt": "2024-11-13T12:48:31.000Z",
      "updatedAt": "2024-11-14T08:12:55.000Z",
      "modified": true
    },
    "react-scan": {
      "authors": [
        "zhw"
      ],
      "title": "聊聊react-scan",
      "tag": "react",
      "path": "react-scan",
      "rawFilePath": "./react-scan.md",
      "coverImage": "https://raw.githubusercontent.com/aidenybai/react-scan/ca7746e2808408c04bcfbfc15486368e67d72bba/.github/assets/logo.svg",
      "text": "# react - scan 核心原理剖析\r\n\r\nreact - scan 是一个用于监听react重渲染的工具，其核心原理是巧妙伪装成 React DevTools，借此成功接入 React 的内部运行机制，从而精准获取 Fiber 节点关键信息，实现对组件更新状况的实时监控。\r\n\r\nReact DevTools 在网页的 window 对象上会挂载一个特殊的全局对象：`__REACT_DEVTOOLS_GLOBAL_HOOK__`。React 在自身运行期间，于某些关键生命周期节点，会调用这个对象上的指定方法，像在 commit 阶段就会调用 `onCommitFiberRoot` 方法，并向其传入当前更新的 FiberRoot 节点作为参数。\r\n\r\nreact - scan 则利用这一点，通过劫持该 hook 上的函数，例如对 `onCommitFiberRoot` 进行重写操作，从而顺利获取整个 React 应用的 Fiber 树根节点。获取根节点后，借助 Fiber 节点的 child 属性指向第一个子节点、sibling 属性指向下一个兄弟节点，就能递归遍历整棵 Fiber 树，进而拿到每一个组件对应的 Fiber 节点详细信息。\r\n\r\n**如何判断组件是否发生更新？**\r\n\r\n  * 对于非 Host 组件（即非原生 DOM 节点）：通过位运算判断其 flags 与 PerformedWork 相与的结果是否为 PerformedWork，以此确定该 Fiber 节点是否发生更新。\r\n  * 对于 Host 组件（对应实际 DOM 节点）：\r\n    * 若不存在 alternate 节点，表明是组件的首次渲染（因为 Fiber 采用双缓冲机制，存在当前树与上一次树之分）。\r\n    * 若存在 alternate 节点，则对比当前与上一次的 memoizedProps（组件属性）、memoizedState（组件状态）、ref，判断组件是否更新。\r\n\r\n**如何定位更新组件的 DOM 元素？**\r\n\r\n一旦确定组件发生更新，可以从对应的 Fiber 节点向上查找最近的 Host 节点（即 Host Fiber），获取其关联的 DOM 元素，进而对 DOM 元素进行高亮或标记操作，方便进行调试或可视化展示。\r\n\r\n**一些其他功能：**\r\n\r\n  * 对比两棵 Fiber 树的 memoizedProps，能够精确知晓具体哪个 prop 发生了变化。\r\n  * 判断是否因 Context 变化引发的组件更新：可通过 fiber.firstContext 获取组件订阅的第一个 Context，然后凭借其 next 属性依次遍历所有订阅的 Context 节点，查找更新源头。\r\n  * 判断是否因为 Hook 更新导致组件更新：鉴于 Fiber 上的 memoizedState 存储着 hooks 链表，可据此分析是哪个 state 发生了变化。",
      "count": "1.1k",
      "readingTime": "5 ",
      "imageUrls": [],
      "createdAt": "2025-05-09T10:11:35.000Z",
      "updatedAt": "2025-05-09T10:11:35.000Z",
      "modified": false
    },
    "rc-field-form": {
      "authors": [
        "zhw"
      ],
      "title": "rc-field-form源码分析",
      "tag": "react",
      "path": "rc-field-form",
      "rawFilePath": "./rc-field-form.md",
      "coverImage": "https://avatars.githubusercontent.com/u/9441414?s=48&v=4",
      "text": "本篇文章将简单分析rc-field-form的源码，rc-field-form是一个react表单管理解决方案，antd的form就是基于他进行的封装，如果大家想要了解react表单的主流解决方案，可以阅读[🍓中台表单技术选型实践(表单实践) - 掘金 (juejin.cn)](https://juejin.cn/post/7316723621292638246#heading-13)\r\n## 用法\r\n首先我们来看看rc-field-form的用法\r\n\r\n```js\r\nimport Form, { useForm, Field } from \"../rc-form\";\r\n\r\nexport default () => {\r\n  const [form] = useForm();\r\n\r\n  return (\r\n    <Form\r\n      onFinish={(e) => {\r\n        console.log(e);\r\n      }}\r\n      onFinishFailed={(e) => {\r\n        console.log(e);\r\n      }}\r\n      form={form}\r\n    >\r\n      <Field name=\"name\" rules={[{ required: true, max: 4 }]}>\r\n        <input placeholder=\"Username\" />\r\n      </Field>\r\n      <Field name=\"password\" rules={[{ required: true, max: 1 }]}>\r\n        <input placeholder=\"Username1\" />\r\n      </Field>\r\n      <button>Submit</button>\r\n    </Form>\r\n  );\r\n};\r\n\r\n```\r\n在这段代码中，使我们使用 Form 组件来新建一个 Form 表单，然后在Field组件里包裹了我们的每一个表单项，并且通过Field的name字段创建表单的key，rules来配置校验。当我们点击button后，会根据是否通过校验来触发onFinsh或者onFinishFailed。\r\n\r\n由此我们可以引出一些问题：\r\n- Form组件是如何管理我们的表单数据\r\n- 我们并没有给每个input绑定事件，表单的值是如何更新的\r\n- Form组件如何对我们的数据进行校验\r\n下面就让我们从源码入手来解决这些问题\r\n# **一**·如何实现数据的更新\r\n### Form组件如何管理数据\r\n根据上面的代码，当我们创建Form组件时，必须要给Form组件传入一个通过useForm这个hook得到的form，那么这个form是什么呢？下面是useForm的源码\r\n\r\n```js\r\nfunction useForm(form) {\r\n  const formRef = React.useRef();\r\n  const [, forceUpdate] = React.useState({});\r\n\r\n  if (!formRef.current) {\r\n    if (form) {\r\n      formRef.current = form;\r\n    } else {\r\n      // Create a new FormStore if not provided\r\n      const forceReRender = () => {\r\n        forceUpdate({});\r\n      };\r\n\r\n      const formStore: FormStore = new FormStore(forceReRender);\r\n\r\n      formRef.current = formStore.getForm();\r\n    }\r\n  }\r\n\r\n  return [formRef.current];\r\n}\r\n\r\n```\r\n当我们在使用useForm的时候，我们一般不会传入form参数，那么这个hook就会帮我们new一个FormStore，FormStore是一个很重要的类，整个表单数据的存储和操作方法都是由他提供，然后返回Formstore的getForm方法，其实这里就是通过getForm将Formstore里的一些属性和方法暴露了出来。\r\n我们先来简单看下FormStore里都有啥(只展示部分属性和方法)\r\n\r\n```js\r\nexport class FormStore {\r\n  //new FormStore时传入的setState方法\r\n  private forceRootUpdate\r\n\r\n  private subscribabl = true;\r\n//整个表单的数据\r\n  private store: Store = {};\r\n//每个Field组件都会被注册到这个数组里\r\n  private fieldEntities = [];\r\n//初始值\r\n  private initialValues = {};\r\n//存放Form上的onFinish等方法\r\n  private callbacks: Callbacks = {};\r\n  \r\n  constructor(forceRootUpdate: () => void) {\r\n    this.forceRootUpdate = forceRootUpdate;\r\n  }\r\n  //暴露出去给开发者的一些方法\r\n   public getForm = (): InternalFormInstance => ({\r\n    getFieldValue: this.getFieldValue,\r\n    getFieldsValue: this.getFieldsValue,\r\n    getFieldWarning: this.getFieldWarning,\r\n    resetFields: this.resetFields,\r\n    setFields: this.setFields,\r\n    setFieldValue: this.setFieldValue,\r\n    setFieldsValue: this.setFieldsValue,\r\n    validateFields: this.validateFields,\r\n    submit: this.submit,\r\n    getInternalHooks: this.getInternalHooks,\r\n    ......\r\n  });\r\n    private getInternalHooks = (key: string): InternalHooks | null => {\r\n    //只提供给内部组件的方法，开发者在其他组件无法调用，这里的HOOK_MAR是Field组件通过context获得的\r\n    if (key === HOOK_MARK) {\r\n      this.formHooked = true;\r\n\r\n      return {\r\n        dispatch: this.dispatch,\r\n        initEntityValue: this.initEntityValue,\r\n        registerField: this.registerField,\r\n        useSubscribe: this.useSubscribe,\r\n        setInitialValues: this.setInitialValues,\r\n        destroyForm: this.destroyForm,\r\n        setCallbacks: this.setCallbacks,\r\n        setValidateMessages: this.setValidateMessages,\r\n        getFields: this.getFields,\r\n        setPreserve: this.setPreserve,\r\n        getInitialValue: this.getInitialValue,\r\n        registerWatch: this.registerWatch,\r\n      };\r\n    }\r\n\r\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\r\n    return null;\r\n  };\r\n```\r\n还有很多方法感觉太多了这里没有列举，我们直接按流程进行分析理解，上面我们讲到了Form组件需要传入form，而form是FormStore通过getForm暴露出的一些属性和方法接下来我们来看看Form组件是如何消费form的\r\n\r\n\r\n```js\r\n//formcontext是用于全局form管理的暂不分析\r\nconst formContext: FormContextProps = React.useContext(FormContext);\r\n//拿到FormStore暴露的属性，方法\r\n  const [formInstance] = useForm(form);\r\n  const {\r\n    useSubscribe,\r\n    setInitialValues,\r\n    setCallbacks,\r\n    setValidateMessages,\r\n    setPreserve,\r\n    destroyForm,\r\n  } = (formInstance as InternalFormInstance).getInternalHooks(HOOK_MARK);\r\n\r\n  // 转发ref让外部可以通过ref调用\r\n  React.useImperativeHandle(ref, () => formInstance);\r\n\r\n  //全局管理有关\r\n  React.useEffect(() => {\r\n    formContext.registerForm(name, formInstance);\r\n    return () => {\r\n      formContext.unregisterForm(name);\r\n    };\r\n  }, [formContext, formInstance, name]);\r\n\r\n  //设置validateMessage\r\n  setValidateMessages({\r\n    ...formContext.validateMessages,\r\n    ...validateMessages,\r\n  });\r\n  //注册form表单上传入的方法\r\n  setCallbacks({\r\n    onValuesChange,\r\n    onFieldsChange: (changedFields: FieldData[], ...rest) => {\r\n      formContext.triggerFormChange(name, changedFields);\r\n\r\n      if (onFieldsChange) {\r\n        onFieldsChange(changedFields, ...rest);\r\n      }\r\n    },\r\n    onFinish: (values: Store) => {\r\n      formContext.triggerFormFinish(name, values);\r\n\r\n      if (onFinish) {\r\n        onFinish(values);\r\n      }\r\n    },\r\n    onFinishFailed,\r\n  });\r\n  setPreserve(preserve);\r\n```\r\n大概就是为FormStore初始化一些东西，对主流程影响不大，我们继续看，下面来到了创建初始值\r\n\r\n```js\r\n//判断是否为首次渲染，首次渲染就创建初始值\r\n  const mountRef = React.useRef(null);\r\n  setInitialValues(initialValues, !mountRef.current);\r\n  if (!mountRef.current) {\r\n    mountRef.current = true;\r\n  }\r\n//每次重新渲染时重置Form\r\n  React.useEffect(\r\n    () => destroyForm,\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [],\r\n  );\r\n\r\n```\r\n我们先来看setInitialValues这个方法\r\n\r\n```js\r\n  private setInitialValues = (initialValues: Store, init: boolean) => {\r\n    this.initialValues = initialValues || {};\r\n    if (init) {\r\n    //merge方法是rc-util提供的工具函数，rc-field-form里的很多操作都用到了里面的函数，这里不做分析\r\n      let nextStore = merge(initialValues, this.store);\r\n    //非主要流程跳过\r\n      this.prevWithoutPreserves?.map(({ key: namePath }) => {\r\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\r\n      });\r\n      this.prevWithoutPreserves = null;\r\n\r\n      this.updateStore(nextStore);\r\n    }\r\n  };\r\n```\r\n我们可以看到setinitalValues方法最后调用了updateStore，这个方法很简单\r\n\r\n```js\r\n  private updateStore = (nextStore: Store) => {\r\n    this.store = nextStore;\r\n  };\r\n```\r\n直接修改了store，接下来是对child不同type的一些处理\r\n\r\n```js\r\n  let childrenNode: React.ReactNode;\r\n  const childrenRenderProps = typeof children === 'function';\r\n  if (childrenRenderProps) {\r\n    const values = formInstance.getFieldsValue(true);\r\n    childrenNode = (children as RenderProps)(values, formInstance);\r\n  } else {\r\n    childrenNode = children;\r\n  }\r\n```\r\n如果child是一个函数，则传入childNode为函数返回值,这里的getFieldsValue方法参数为true时返回的就是整个store，也可以传入Field的name数组获取指定的value，具体实现不做分析。继续继续😊\r\n\r\n```js\r\nconst formContextValue = React.useMemo(\r\n    () => ({\r\n      ...(formInstance as InternalFormInstance),\r\n      validateTrigger,\r\n    }),\r\n    [formInstance, validateTrigger],\r\n  );\r\n```\r\n然后我们创建了一个context，传入formInstance(FormStore暴露的方法和数据)，还有一个validateTrigger，这个我们之前没有提到，这个属性是用户传给Form组件的，他的默认值是onChange,也就是说在onChange的时候会触发Field组件的validate。马上就到尾声了(其实是Form的尾声，后面还有一堆)\r\n\r\n```js\r\n  const wrapperNode = (\r\n    <ListContext.Provider value={null}>\r\n      <FieldContext.Provider value={formContextValue}>{childrenNode}</FieldContext.Provider>\r\n    </ListContext.Provider>\r\n  );\r\n```\r\n接下创建一个wrapperNode，其实就是一个contextProvider，ListContext.Provider这个应该是为List组件服务的我们暂不关心，然后我们可以看到FieldContext.Provider就是提供了formInstance和validateTrigger，这样我们的Field组件也可以访问和操作formInstance啦。\r\n然后就是我们最后的代码\r\n\r\n```js\r\n  if (Component === false) {\r\n    return wrapperNode;\r\n  }\r\n\r\n  return (\r\n    <Component\r\n      {...restProps}\r\n      onSubmit={(event: React.FormEvent<HTMLFormElement>) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        formInstance.submit();\r\n      }}\r\n      onReset={(event: React.FormEvent<HTMLFormElement>) => {\r\n        event.preventDefault();\r\n\r\n        formInstance.resetFields();\r\n        restProps.onReset?.(event);\r\n      }}\r\n    >\r\n      {wrapperNode}\r\n    </Component>\r\n  );\r\n};\r\n```\r\n这里的Component也是由用户传入的，默认值为'form'，所以最后的效果其实是\r\n```js    \r\n    <form\r\n      {...restProps}\r\n      onSubmit={(event: React.FormEvent<HTMLFormElement>) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        formInstance.submit();\r\n      }}\r\n      onReset={(event: React.FormEvent<HTMLFormElement>) => {\r\n        event.preventDefault();\r\n\r\n        formInstance.resetFields();\r\n        restProps.onReset?.(event);\r\n      }}\r\n    >\r\n      {wrapperNode}\r\n    </form>\r\n```\r\n这里阻止了一下form的默认行为，然后会在submit和reset时执行formInstance的方法。\r\n\r\n到这里我们先总结一下，Form组件都干了什么\r\n- 首先他拿到了form然后setCallbacks，setInitialValues对forminstance的callback和store进行了初始化\r\n- 然后对children进行了处理，用FieldContext将它包裹，让Field组件可以拿到formInstance等一些东西\r\n- 最后用form标签将处理后的child包裹起来，将事件进行绑定\r\n### Field如何消费数据\r\n接下来让我们继续看看Feld组件，Field组件有一点特殊，他是一个class组件🤔，源码中注释是\r\n` We use Class instead of Hooks here since it will cost much code by using Hooks.`大概意思是通过class组件的方式实现可以减少代码量。我们先来看看Field组件大致的代码结构。\r\n```js\r\nclass Field extends React.Component<InternalFieldProps, FieldState> implements FieldEntity {\r\n    //传入的formInstance\r\n    public static contextType = FieldContext;\r\n    //组件默认参数\r\n    public static defaultProps\r\n    //定义一个state用于触发rerender\r\n    public state \r\n    //用于组件卸载时清除formInstance里数据\r\n    private cancelRegisterFunc\r\n    //是否已挂载\r\n    private mounted = false;\r\n    //表单校验结果的Promise\r\n    private validatePromise\r\n    //校验结果error\r\n    private errors\r\n    //校验结果 warning\r\n    private warnings\r\n  \r\n    constructor(props) {\r\n        super()\r\n        ..........\r\n    }\r\n  \r\n    public componentDidMount\r\n  \r\n    public componentWillUnmount() {\r\n    }\r\n    //会调用并销毁cancelRegisterFunc\r\n    public cancelRegister\r\n    //获取Field的name\r\n    public getNamePath\r\n    //获取传入的rules\r\n    public getRules\r\n    //用于更新组件\r\n    public reRender\r\n    public refresh\r\n    // ========================= 这个方法很重要，跟组件更新相关 ==============================\r\n    public onStoreChange\r\n    //校验rulues的方法\r\n    public validateRules\r\n    public isFieldValidating = () => !!this.validatePromise;\r\n   //获取校验后的结果\r\n    public getErrors\r\n    public getWarnings\r\n   //对传入的child的一些处理\r\n    public getOnlyChild\r\n    //返回当前Field字段的值\r\n    public getValue\r\n    // ======== 就是这个方法让我们传入的组件受控，劫持了组件的onChange这类事件 ====================\r\n    public getControlled\r\n    //返回处理后的子组件\r\n    public render() {\r\n    \r\n    }\r\n  }\r\n```\r\n了解了大体结构，接下来我们先从constructor入手，看看Field组件的渲染流程。\r\n\r\n```js\r\n  constructor(props: InternalFieldProps) {\r\n    super(props);\r\n\r\n    // Register on init\r\n    if (props.fieldContext) {\r\n      const { getInternalHooks }: InternalFormInstance = props.fieldContext;\r\n      const { initEntityValue } = getInternalHooks(HOOK_MARK);\r\n      initEntityValue(this);\r\n    }\r\n  }\r\n\r\n```\r\n这里其实就是调用了initEntityValue这个函数，传入Field组件\r\n\r\n```js\r\n private initEntityValue = (entity: FieldEntity) => {\r\n    const { initialValue } = entity.props;\r\n\r\n    if (initialValue !== undefined) {\r\n      const namePath = entity.getNamePath();\r\n      const prevValue = getValue(this.store, namePath);\r\n\r\n      if (prevValue === undefined) {\r\n        this.updateStore(setValue(this.store, namePath, initialValue));\r\n      }\r\n    }\r\n  };\r\n```\r\n这里就是简单设置了一下初始值并不会引起Field的rerender，接下来我们继续看Field组件都做了哪些初始化\r\n\r\n```js\r\n  public componentDidMount() {\r\n    const {  fieldContext } = this.props;\r\n     //标记为已挂载\r\n    this.mounted = true;\r\n\r\n    if (fieldContext) {\r\n      const { getInternalHooks }: InternalFormInstance = fieldContext;\r\n      const { registerField } = getInternalHooks(HOOK_MARK);\r\n      //\r\n      this.cancelRegisterFunc = registerField(this);\r\n    }\r\n  }\r\n```\r\n这里的核心就是registerField，还记得我们之前提到过formStore的fieldEntities数组里存储了Field吗，这个函数其实核心就是fieldEntities.push(field)，然后给我们返回了一个函数用于在fieldEntities里delete这个Field，这样我们就可以通过formInstance调用Field里暴露的一些方法用于更新或者校验。 \r\n\r\n然后就是render函数\r\n\r\n```js\r\n public render() {\r\n    const { resetCount } = this.state;\r\n    const { children } = this.props;\r\n\r\n    const { child, isFunction } = this.getOnlyChild(children);\r\n\r\n    // Not need to `cloneElement` since user can handle this in render function self\r\n    let returnChildNode: React.ReactNode;\r\n    if (isFunction) {\r\n      returnChildNode = child;\r\n    } else if (React.isValidElement(child)) {\r\n      returnChildNode = React.cloneElement(\r\n        child as React.ReactElement,\r\n        this.getControlled((child as React.ReactElement).props),\r\n      );\r\n    } else {\r\n      warning(!child, '`children` of Field is not validate ReactElement.');\r\n      returnChildNode = child;\r\n    }\r\n\r\n    return <React.Fragment key={resetCount}>{returnChildNode}</React.Fragment>;\r\n  }\r\n}\r\n```\r\ngetonlychild返回第一个child和他的类型，当child是合法的reactElement时，调用[cloneElement方法](https://react.dev/reference/react/cloneElement)，然后返回Fragment包裹的cloneElement，所以这里的关键就是这个cloneElement的第二个参数，这里到底传入了什么东西🤨。  \r\n简单地说，cloneElement的第二个参数其实是`props`，它可以覆盖默认的props，fc-field-form就是在这里接管了Field的onChange等一系列事件，我们来看看getControlled的源码\r\n\r\n```js\r\n  public getControlled = (childProps: ChildProps = {}) => {\r\n  //获取Field的一些方法和数据\r\n    const {\r\n      name,\r\n      trigger,\r\n      validateTrigger,\r\n      getValueFromEvent,\r\n      normalize,\r\n      valuePropName,\r\n      getValueProps,\r\n      fieldContext,\r\n    } = this.props;\r\n   //校验有关,其实就是一些事件的name，如'onChange'\r\n    const mergedValidateTrigger =\r\n      validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\r\n    //当前field name\r\n    const namePath = this.getNamePath();\r\n    const { getInternalHooks, getFieldsValue }: InternalFormInstance = fieldContext;\r\n    //---------- dispatch传入不同的参数可以分发不同操作如校验，更新 ----------------\r\n    const { dispatch } = getInternalHooks(HOOK_MARK);\r\n    const value = this.getValue();\r\n    //不太重要，给子元素提供一个可以获取value的方法\r\n    const mergedGetValueProps = getValueProps || ((val: StoreValue) => ({ [valuePropName]: val }));\r\n    //同上\r\n    const valueProps = name !== undefined ? mergedGetValueProps(value) : {};\r\n        //trigger的默认值是onChange，如果我们在某个Field的input里绑定了onChange事件，这里就可以拿到\r\n    const originTriggerFunc = childProps[trigger];\r\n    // warning when prop value is function\r\n    if (process.env.NODE_ENV !== 'production' && valueProps) {\r\n      Object.keys(valueProps).forEach(key => {\r\n        warning(\r\n          typeof valueProps[key] !== 'function',\r\n          `It's not recommended to generate dynamic function prop by \\`getValueProps\\`. Please pass it to child component directly (prop: ${key})`,\r\n        );\r\n      });\r\n    }\r\n    //这个control就是我们要返回的props，现在还几乎没有啥真正有用的变化\r\n    const control = {\r\n      ...childProps,\r\n      ...valueProps,\r\n    };\r\n    //------------------------------- 劫持事件了 ------------------------------------\r\n    control[trigger] = (...args: EventArgs) => {\r\n      //修改一些状态\r\n      this.touched = true;\r\n      this.dirty = true;\r\n\r\n      this.triggerMetaEvent();\r\n\r\n      let newValue: StoreValue;\r\n      //默认为空，用户可以传入，就是获取事件返回值\r\n      if (getValueFromEvent) {\r\n        newValue = getValueFromEvent(...args);\r\n      } else {\r\n      //用户不传入使用默认方法\r\n        newValue = defaultGetValueFromEvent(valuePropName, ...args);\r\n      }\r\n      //对数据进行一些格式化处理\r\n      if (normalize) {\r\n        newValue = normalize(newValue, value, getFieldsValue(true));\r\n      }\r\n       //分发更新事件\r\n      dispatch({\r\n        type: 'updateValue',\r\n        namePath,\r\n        value: newValue,\r\n      });\r\n       //如果用户还绑定了事件，调用用户原来绑定的事件\r\n      if (originTriggerFunc) {\r\n        originTriggerFunc(...args);\r\n      }\r\n    };\r\n    \r\n    //触发校验的数组，如['onChange'],后面的先不看属于校验的内容\r\n     const validateTriggerList: string[] = toArray(mergedValidateTrigger || []);\r\n\r\n    validateTriggerList.forEach((triggerName: string) => {\r\n      // Wrap additional function of component, so that we can get latest value from store\r\n      const originTrigger = control[triggerName];\r\n      control[triggerName] = (...args: EventArgs) => {\r\n        if (originTrigger) {\r\n          originTrigger(...args);\r\n        }\r\n\r\n        // Always use latest rules\r\n        const { rules } = this.props;\r\n        if (rules && rules.length) {\r\n          // We dispatch validate to root,\r\n          // since it will update related data with other field with same name\r\n          dispatch({\r\n            type: 'validateField',\r\n            namePath,\r\n            triggerName,\r\n          });\r\n        }\r\n      };\r\n    });\r\n\r\n    return control;\r\n  };\r\n```\r\n到了这里其实我们已经找到了rc-field-form在表单触发事件时，虽然我们并没有绑定事件，但是它已经将其劫持，并且通过dispatch这个函数通知formStore进行数据上的更新。接下来我们一起来探索data和ui是如何更新。\r\n\r\ndispatch这个函数的代码很少，如下\r\n```js\r\n  private dispatch = (action: ReducerAction) => {\r\n    switch (action.type) {\r\n      case 'updateValue': {\r\n        const { namePath, value } = action;\r\n        this.updateValue(namePath, value);\r\n        break;\r\n      }\r\n      case 'validateField': {\r\n        const { namePath, triggerName } = action;\r\n        this.validateFields([namePath], { triggerName });\r\n        break;\r\n      }\r\n      default:\r\n      // Currently we don't have other action. Do nothing.\r\n    }\r\n  };\r\n```\r\n可以看到，我们触发updateVlue进入了updateValue这个函数\r\n\r\n```js\r\n  private updateValue = (name: NamePath, value: StoreValue) => {\r\n    const namePath = getNamePath(name);\r\n    const prevStore = this.store;\r\n    this.updateStore(setValue(this.store, namePath, value));\r\n\r\n    this.notifyObservers(prevStore, [namePath], {\r\n      type: 'valueUpdate',\r\n      source: 'internal',\r\n    });\r\n    ......\r\n  };\r\n```\r\n 简略后的代码如上，updateStore更新了一下store，其实到这里我们就已经将formInstance的store更新了，接下来思考的是如何更新ui，我们一起来看看这个notifyObservers函数\r\n \r\n```js\r\n private notifyObservers = (\r\n    prevStore: Store,\r\n    namePathList: InternalNamePath[] | null,\r\n    info: NotifyInfo,\r\n  ) => {\r\n    if (this.subscribable) {\r\n    //合并info和store\r\n      const mergedInfo: ValuedNotifyInfo = {\r\n        ...info,\r\n        store: this.getFieldsValue(true),\r\n      };\r\n      //获取所有Field，执行每个Field的onStoreChange方法\r\n      this.getFieldEntities().forEach(({ onStoreChange }) => {\r\n        onStoreChange(prevStore, namePathList, mergedInfo);\r\n      });\r\n    } else {\r\n      this.forceRootUpdate();\r\n    }\r\n  };\r\n```\r\n还记得我们提到过Field里的onStoreChange与更新有关吗，没错现在这一切都连了起来。\r\n\r\n```js\r\npublic onStoreChange: FieldEntity['onStoreChange'] = (prevStore, namePathList, info) => {\r\n  const { shouldUpdate, dependencies = [], onReset } = this.props;\r\n  const { store } = info;\r\n  const namePath = this.getNamePath();\r\n  const prevValue = this.getValue(prevStore);\r\n  const curValue = this.getValue(store);\r\n  //匹配是否包含当前name\r\n  const namePathMatch = namePathList && containsNamePath(namePathList, namePath);\r\n\r\n  // 为setFieldValue这样的api服务的\r\n  if (\r\n    info.type === 'valueUpdate' &&\r\n    info.source === 'external' &&\r\n    !isEqual(prevValue, curValue)\r\n  ) {\r\n    this.touched = true;\r\n    this.dirty = true;\r\n    this.validatePromise = null;\r\n    this.errors = EMPTY_ERRORS;\r\n    this.warnings = EMPTY_ERRORS;\r\n    this.triggerMetaEvent();\r\n  }\r\n  //其他代码省略，我们这里是default\r\n  switch (info.type) {\r\n    case 'reset':\r\n    case 'remove':\r\n    case 'setField':\r\n    case 'dependenciesUpdate'\r\n    default:\r\n    //一些是否需要更新的判断\r\n      if (\r\n        namePathMatch ||\r\n        ((!dependencies.length || namePath.length || shouldUpdate) &&\r\n          requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info))\r\n      ) {\r\n      //调用方法更新\r\n        this.reRender();\r\n        return;\r\n      }\r\n      break;\r\n  }\r\n\r\n  if (shouldUpdate === true) {\r\n    this.reRender();\r\n  }\r\n  };\r\n```\r\nrerender方法也很简单，就是使用了类组件的forceUpdate强制更新\r\n```js\r\n  public reRender() {\r\n    if (!this.mounted) return;\r\n    this.forceUpdate();\r\n  }\r\n```\r\n到这里，我们已经知道了表单如何进行最基本的更新，这里放一张字节大佬的图\r\n\r\n![64652037b3ee4d1184d79e8e105e2429~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75[1].awebp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a88f033593474fd58c47fa0bc79d781c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1588&h=778&s=46900&e=webp&b=fffefe)\r\n再理一下思路\r\n1. 首先我们在Form组件中创建了formInstance,将初始值和一些callback绑定到了form上，然后通过FieldContext将formInstance下放到每个Field组件里实现了方法和数据的共享\r\n2. 在Field组件中，它会在componentDidMount阶段被注册到formInstance中，然后我们通过cloneElement这个api对传入Field的子组件的事件进行了劫持，当触发某生事件时Field组件调用formInstance的dispath方法开始触发更新\r\n3. dispath根据不同的action type会派发不同的事件，在updateVlue的情况下调用了updateValue方法，这个方法中首先通过updateStore方法对Store中的数据进行了更新，然后调用notifyObserver方法，notifyObserver会遍历所有Field组件，调用他们的onStorechange方法，每个Field组件会判断是否需要更新和更新的类型(如reset,setField),然后据此进行不同的操作，最后更新的方法是refresh()，其实就是调用了类组件的forceUpdate方法  \r\n\r\n上面这种更新方式是通过用户的一些行为，我们也可以通过forminstance暴露的一些方法如setFieldsValue对表单进行更新，我们再来看看这是如何做到的\r\n\r\n```js\r\nprivate setFieldsValue = (store: Store) => {\r\n  //防止用户在form组件外使用\r\n  this.warningUnhooked();\r\n\r\n  const prevStore = this.store;\r\n  //更新store数据\r\n  if (store) {\r\n    const nextStore = merge(this.store, store);\r\n    this.updateStore(nextStore);\r\n  }\r\n//还是通过notifyObservers触发所有Field的onStorechange\r\n  this.notifyObservers(prevStore, null, {\r\n    type: 'valueUpdate',\r\n    source: 'external',\r\n  });\r\n  ......\r\n};\r\n```\r\n最后走到onStorechange的代码\r\n\r\n```js\r\ncase 'setField': {\r\n  const { data } = info;\r\n  if (namePathMatch) {\r\n    if ('touched' in data) {\r\n      this.touched = data.touched;\r\n    }\r\n    if ('validating' in data && !('originRCField' in data)) {\r\n      this.validatePromise = data.validating ? Promise.resolve([]) : null;\r\n    }\r\n    if ('errors' in data) {\r\n      this.errors = data.errors || EMPTY_ERRORS;\r\n    }\r\n    if ('warnings' in data) {\r\n      this.warnings = data.warnings || EMPTY_ERRORS;\r\n    }\r\n    this.dirty = true;\r\n\r\n    this.triggerMetaEvent();\r\n\r\n    this.reRender();\r\n    return;\r\n  } else if ('value' in data && containsNamePath(namePathList, namePath, true)) {\r\n          // Contains path with value should also check\r\n    this.reRender();\r\n    return;\r\n  }\r\n```\r\n只是多了一些数据的处理，其他代码都差不多，到这里form的更新大概就聊完了，接下来我们来说说表单校验是如何实现的。\r\n# 二·如何实现校验\r\n### 如何触发校验\r\n想要知道校验的实现，我们还是得先看看有哪些方法可以触发form表单的校验，首先是formInstance的submit\r\n\r\n```js\r\nprivate submit = () => {\r\n  this.warningUnhooked();\r\n//这个就是校验相关的函数\r\n  this.validateFields()\r\n    .then(values => {\r\n      const { onFinish } = this.callbacks;\r\n      if (onFinish) {\r\n        try {\r\n          onFinish(values);\r\n        } catch (err) {\r\n          // Should print error if user `onFinish` callback failed\r\n          console.error(err);\r\n        }\r\n      }\r\n    })\r\n    .catch(e => {\r\n      const { onFinishFailed } = this.callbacks;\r\n      if (onFinishFailed) {\r\n        onFinishFailed(e);\r\n      }\r\n    });\r\n};\r\n}\r\n```\r\n还有当一些用户行为触发的事件如onChange，其实这也是在getControlled里帮我们劫持了\r\n\r\n```js\r\n\r\n  ...\r\n  //触发校验的event name数组\r\n const validateTriggerList: string[] = toArray(mergedValidateTrigger || []);\r\n\r\n validateTriggerList.forEach((triggerName: string) => {\r\n   // Wrap additional function of component, so that we can get latest value from store\r\n   const originTrigger = control[triggerName];\r\n   //劫持并添加校验逻辑\r\n   control[triggerName] = (...args: EventArgs) => {\r\n     if (originTrigger) {\r\n       originTrigger(...args);\r\n     }\r\n\r\n     // 如果存在rules就dispatch派发校验\r\n     const { rules } = this.props;\r\n     if (rules && rules.length) {\r\n       // We dispatch validate to root,\r\n       // since it will update related data with other field with same name\r\n       dispatch({\r\n         type: 'validateField',\r\n         namePath,\r\n         triggerName,\r\n       });\r\n     }\r\n```\r\n这里的dispatch也会触发formInstance的validateFields方法，下面我们就把注意力放到这个函数中\r\n### 校验的实现\r\n\r\n```js\r\nprivate validateFields: InternalValidateFields = (arg1?: any, arg2?: any) => {\r\n  this.warningUnhooked();\r\n\r\n  let nameList: NamePath[];\r\n  let options: InternalValidateOptions;\r\n  //对不同形式传入参数的一些处理\r\n  if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\r\n    nameList = arg1;\r\n    options = arg2;\r\n  } else {\r\n    options = arg1;\r\n  }\r\n  //获取传入的Field name\r\n  const provideNameList = !!nameList;\r\n  const namePathList: InternalNamePath[] | undefined = provideNameList\r\n    ? nameList.map(getNamePath)\r\n    : [];\r\n\r\n  // 用来收集后续的校验\r\n  const promiseList: Promise<FieldError>[] = [];\r\n\r\n  //遍历每个Field判断是否需要校验\r\n  this.getFieldEntities(true).forEach((field: FieldEntity) => {\r\n    // 如果没有传入namelist就把所有Field加入namePathList中\r\n    if (!provideNameList) {\r\n      namePathList.push(field.getNamePath());\r\n    }\r\n\r\n    // 如果没有配置rule就不需要后续操作\r\n    if (!field.props.rules || !field.props.rules.length) {\r\n      return;\r\n    }\r\n\r\n    const fieldNamePath = field.getNamePath();\r\n \r\n\r\n    //调用Field的校验方法，保存该方法的Promise\r\n    if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\r\n      const promise = field.validateRules({\r\n        validateMessages: {\r\n          ...defaultValidateMessages,\r\n          ...this.validateMessages,\r\n        },\r\n        ...options,\r\n      });\r\n\r\n      // 将保存的Promise推入之前创建的promiseList中\r\n      promiseList.push(\r\n        promise\r\n          .then<any, RuleError>(() => ({ name: fieldNamePath, errors: [], warnings: [] }))\r\n          .catch((ruleErrors: RuleError[]) => {\r\n          //保留错误和warnings\r\n            const mergedErrors: string[] = [];\r\n            const mergedWarnings: string[] = [];\r\n            //根据传入的不同配置对错误进行不同处理         \r\n            ruleErrors.forEach?.(({ rule: { warningOnly }, errors }) => {\r\n              if (warningOnly) {\r\n                mergedWarnings.push(...errors);\r\n              } else {\r\n                mergedErrors.push(...errors);\r\n              }\r\n            });\r\n             //根据是否有错误返回不同结果\r\n            if (mergedErrors.length) {\r\n              return Promise.reject({\r\n                name: fieldNamePath,\r\n                errors: mergedErrors,\r\n                warnings: mergedWarnings,\r\n              });\r\n            }\r\n\r\n            return {\r\n              name: fieldNamePath,\r\n              errors: mergedErrors,\r\n              warnings: mergedWarnings,\r\n            };\r\n          }),\r\n      );\r\n      }\r\n  });\r\n   //收集所有检验项的结果\r\n  const summaryPromise = allPromiseFinish(promiseList);\r\n    //将这次校验的结果保存在formInstance中\r\n  this.lastValidatePromise = summaryPromise;\r\n\r\n  // Notify fields with rule that validate has finished and need update\r\n  summaryPromise\r\n    .catch(results => results)\r\n    .then((results: FieldError[]) => {\r\n      const resultNamePathList: InternalNamePath[] = results.map(({ name }) => name);\r\n      //通知Field进行更新\r\n      this.notifyObservers(this.store, resultNamePathList, {\r\n        type: 'validateFinish',\r\n      });\r\n      this.triggerOnFieldsChange(resultNamePathList, results);\r\n    });\r\n    //这个Promise将会被作为返回值，在submit的时候会起到作用\r\n  const returnPromise: Promise<Store | ValidateErrorEntity | string[]> = summaryPromise\r\n    .then((): Promise<Store | string[]> => {\r\n    //如果没有规则错误就直接返回所有校验项的值\r\n      if (this.lastValidatePromise === summaryPromise) {\r\n        return Promise.resolve(this.getFieldsValue(namePathList));\r\n      }\r\n      return Promise.reject<string[]>([]);\r\n    })\r\n    .catch((results: { name: InternalNamePath; errors: string[] }[]) => {\r\n    //存在错误将错误整理返回\r\n      const errorList = results.filter(result => result && result.errors.length);\r\n      return Promise.reject({\r\n        values: this.getFieldsValue(namePathList),\r\n        errorFields: errorList,\r\n        outOfDate: this.lastValidatePromise !== summaryPromise,\r\n      });\r\n    });\r\n\r\n  // Do not throw in console\r\n  returnPromise.catch<ValidateErrorEntity>(e => e);\r\n\r\n  return returnPromise as Promise<Store>;\r\n  };\r\n```\r\n这里的代码比较长，我们来整理一下关键的地方：如果传入了nameList那么会对nameList对应的Field进行校验，否则就会全部校验，当然他们需要传入了rules，而这里的校验方法其实是调用的Field组件的validateRules方法，这个函数我们后续会分析，然后我们会把validateRules返回的promise收集到promiseList中，通过allPromiseFinish函数，我们就可以拿到校验结果的数组了，接下来主要就是2件事，一是通知对应的Field进行更新，二是根据校验结果返回Promise作为 onFinishFailed和onFinish的触发依据，这里的逻辑也比较简单。所以下面我们就来看看Field组件中的validateRules方法\r\n\r\n```js\r\npublic validateRules = (options?: InternalValidateOptions): Promise<RuleError[]> => {\r\n\r\n  const namePath = this.getNamePath();\r\n  const currentValue = this.getValue();\r\n\r\n  const { triggerName, validateOnly = false } = options || {};\r\n  \r\n  const rootPromise = Promise.resolve().then(async (): Promise<any[]> => {\r\n    if (!this.mounted) {\r\n      return [];\r\n    }\r\n\r\n    const { validateFirst = false, messageVariables, validateDebounce } = this.props;\r\n\r\n    // 对rule的一些过滤，这里主要是排除空校验和触发时机不满足的\r\n    let filteredRules = this.getRules();\r\n    if (triggerName) {\r\n      filteredRules = filteredRules\r\n        .filter(rule => rule)\r\n        .filter((rule: RuleObject) => {\r\n          const { validateTrigger } = rule;\r\n          if (!validateTrigger) {\r\n            return true;\r\n          }\r\n          const triggerList = toArray(validateTrigger);\r\n          return triggerList.includes(triggerName);\r\n        });\r\n    }\r\n    \r\n     ......\r\n     \r\n    //其实这个promise就是包含了当前检验结果的promise\r\n    const promise = validateRules(\r\n      namePath,\r\n      currentValue,\r\n      filteredRules,\r\n      options,\r\n      validateFirst,\r\n      messageVariables,\r\n    );\r\n\r\n    promise\r\n      .catch(e => e)\r\n      .then((ruleErrors: RuleError[] = EMPTY_ERRORS) => {\r\n        if (this.validatePromise === rootPromise) {\r\n          this.validatePromise = null;\r\n\r\n          //根据option处理数据跟前面相似\r\n          const nextErrors: string[] = [];\r\n          const nextWarnings: string[] = [];\r\n          ruleErrors.forEach?.(({ rule: { warningOnly }, errors = EMPTY_ERRORS }) => {\r\n            if (warningOnly) {\r\n              nextWarnings.push(...errors);\r\n            } else {\r\n              nextErrors.push(...errors);\r\n            }\r\n          });\r\n           把结果存储在当前Field上\r\n          this.errors = nextErrors;\r\n          this.warnings = nextWarnings;\r\n          this.triggerMetaEvent();\r\n          this.reRender();\r\n        }\r\n      });\r\n\r\n    return promise;\r\n  });\r\n\r\n  if (validateOnly) {\r\n    return rootPromise;\r\n  }\r\n  //一些数据的更新\r\n  this.validatePromise = rootPromise;\r\n  this.dirty = true;\r\n  this.errors = EMPTY_ERRORS;\r\n  this.warnings = EMPTY_ERRORS;\r\n  this.triggerMetaEvent();\r\n\r\n  // Force trigger re-render since we need sync renderProps with new meta\r\n  this.reRender();\r\n  //可以看到正常流程下其实就是返回的validateRules(...args)的promise结果\r\n  return rootPromise;\r\n  };\r\n```\r\n所以这里的大部分代码还是在进行流程的串联和Field内部状态的一些处理，校验相关的还是也并非在这里实现，其实rc-field-form的表单校验依赖了rc-component/async-validator，然后对其进行了一些封装，这里也不做过多介绍了。\r\n# 三 一些其他功能\r\n上面聊完了form的核心功能，下面我们再来看一看一些比较好用的特性.\r\n首先是list组件，这里我放一个[antd的例子](https://ant.design/components/form-cn#components-form-demo-dynamic-form-item)，不熟悉的可以去了解一下效果。\r\n### List\r\n\r\n```js\r\n <List name='xxx'>\r\n {(fields, { add, remove }, { errors }) => (\r\n          <>\r\n            {fields.map((field, index) => (\r\n                <Field\r\n                  {...field}\r\n                >\r\n                  <Input placeholder=\"passenger name\"/>\r\n                </Field>\r\n            ))}\r\n          </>\r\n        )}\r\n      </List>\r\n```\r\n大概的使用方法如上，我们需要给List组件传入一个函数，然后在这个函数里通过组件给我们的fields参数进行遍历渲染出每个Field，同时他也给我们提供了一些方法对数据进行操控，下面我们一起来看看如何实现。先贴出这个组件的代码，然后我们来慢慢分析。\r\n\r\n```js\r\nfunction List<Values = any>({\r\n  name,\r\n  initialValue,\r\n  children,\r\n  rules,\r\n  validateTrigger,\r\n  isListField,\r\n}: ListProps<Values>) {\r\n//存放了formInstance和validateTrigger\r\n  const context = React.useContext(FieldContext);\r\n  //现在这里还没有东西\r\n  const wrapperListContext = React.useContext(ListContext);\r\n  const keyRef = React.useRef({\r\n    keys: [],\r\n    id: 0,\r\n  });\r\n  const keyManager = keyRef.current;\r\n  //获取当前的Fieldname\r\n  const prefixName: InternalNamePath = React.useMemo(() => {\r\n    const parentPrefixName = getNamePath(context.prefixName) || [];\r\n    return [...parentPrefixName, ...getNamePath(name)];\r\n  }, [context.prefixName, name]);\r\n  //创建context传递firminstance和name\r\n  const fieldContext = React.useMemo(() => ({ ...context, prefixName }), [context, prefixName]);\r\n\r\n  // 创建list的context\r\n  const listContext = React.useMemo<ListContextProps>(\r\n    () => ({\r\n      getKey: (namePath: InternalNamePath) => {\r\n        const len = prefixName.length;\r\n        const pathName = namePath[len];\r\n        return [keyManager.keys[pathName], namePath.slice(len + 1)];\r\n      },\r\n    }),\r\n    [prefixName],\r\n  );\r\n  // list组件的children只能传入函数\r\n  if (typeof children !== 'function') {\r\n    warning(false, 'Form.List only accepts function as children.');\r\n    return null;\r\n  }\r\n //辅助更新\r\n  const shouldUpdate = (prevValue: StoreValue, nextValue: StoreValue, { source }) => {\r\n    if (source === 'internal') {\r\n      return false;\r\n    }\r\n    return prevValue !== nextValue;\r\n  };\r\n \r\n  return (\r\n    <ListContext.Provider value={listContext}>\r\n      <FieldContext.Provider value={fieldContext}>\r\n        <Field\r\n          name={[]}\r\n          shouldUpdate={shouldUpdate}\r\n          rules={rules}\r\n          validateTrigger={validateTrigger}\r\n          initialValue={initialValue}\r\n          isList\r\n          isListField={isListField ?? !!wrapperListContext}\r\n        >\r\n         .........\r\n         \r\n        </Field>\r\n      </FieldContext.Provider>\r\n    </ListContext.Provider>\r\n  );\r\n}\r\n```\r\n看到这里其实我们能够发现，list组件其实还是根据Field组件进行的封装，现在我们再来看看Field组件里都有什么东西\r\n\r\n```js\r\n{({ value = [], onChange }, meta) => {\r\n  const { getFieldValue } = context;\r\n  //获取当前Filed维护的值\r\n  const getNewValue = () => {\r\n      const values = getFieldValue(prefixName || []) as StoreValue[];\r\n      return values || [];\r\n };\r\n    const operations: ListOperations = {\r\n      add: (defaultValue, index?: number) => {\r\n         // Mapping keys\r\n        const newValue = getNewValue();\r\n        console.log(newValue,defaultValue)\r\n         if (index >= 0 && index <= newValue.length) {\r\n          keyManager.keys = [\r\n             ...keyManager.keys.slice(0, index),\r\n            keyManager.id,\r\n             ...keyManager.keys.slice(index),\r\n          ];\r\n          onChange([...newValue.slice(0, index), defaultValue, ...newValue.slice(index)]);\r\n         } else {\r\n          if (\r\n             process.env.NODE_ENV !== 'production' &&\r\n            (index < 0 || index > newValue.length)\r\n           ) {\r\n             warning(\r\n                false,\r\n               'The second parameter of the add function should be a valid positivenumber.',\r\n             );\r\n           }\r\n           keyManager.keys = [...keyManager.keys, keyManager.id];\r\n           console.log(keyManager)\r\n           onChange([...newValue, defaultValue]);\r\n        }\r\n         keyManager.id += 1;\r\n      }，\r\n\r\n     let listValue = value || [];\r\n     if (!Array.isArray(listValue)) {\r\n      listValue = [];\r\n\r\n       if (process.env.NODE_ENV !== 'production') {\r\n         warning(\r\n           false,\r\n           `Current value of '${prefixName.join(' > ')}' is not an array type.`,\r\n         );\r\n       }\r\n     }\r\n\r\n    return children(\r\n      (listValue as StoreValue[]).map((__, index): ListField => {\r\n        let key = keyManager.keys[index];\r\n        if (key === undefined) {\r\n         keyManager.keys[index] = keyManager.id;\r\n            key = keyManager.keys[index];\r\n            keyManager.id += 1;\r\n          }\r\n\r\n         return {\r\n           name: index,\r\n           key,\r\n           isListField: true,\r\n         };\r\n       }),\r\n       operations,\r\n       meta,\r\n     );\r\n    }}\r\n```\r\n 首先我们注意到，Field组件里我们传入的也是一个函数，这里需要先带大家复习一下，在Field组件中，如果我们传入的child是一个函数，那么会传入getControlled(), meta,fieldContext这3个参数(相关函数getOnlyChild )，并将函数的返回值作为最终的child,meta其实就是Field的一些状态，接下来来看看operations\r\n\r\n```js\r\n   const operations: ListOperations = {\r\n      add: (defaultValue, index?: number) => {\r\n         // 其实这里获取的就是当前的值\r\n        const newValue = getNewValue();\r\n        如果传入了index并且index没有超出当前index就插入\r\n         if (index >= 0 && index <= newValue.length) {\r\n          keyManager.keys = [\r\n             ...keyManager.keys.slice(0, index),\r\n            keyManager.id,\r\n             ...keyManager.keys.slice(index),\r\n          ];\r\n          //一个onChange方法，传入了新值\r\n          onChange([...newValue.slice(0, index), defaultValue, ...newValue.slice(index)]);\r\n         } else {\r\n          if (\r\n             process.env.NODE_ENV !== 'production' &&\r\n            (index < 0 || index > newValue.length)\r\n           ) {\r\n           //一些错误处理\r\n             warning(\r\n                false,\r\n               'The second parameter of the add function should be a valid positivenumber.',\r\n             );\r\n           }\r\n           //否者默认将值更新到最后\r\n           keyManager.keys = [...keyManager.keys, keyManager.id];\r\n           onChange([...newValue, defaultValue]);\r\n        }\r\n         keyManager.id += 1;\r\n      }，\r\n```\r\n其实这一部分就是维护了一个对象，提供了之前add等一些修改数据的方法，其他方法这里省略了。\r\n\r\n```js\r\n let listValue = value || [];\r\n if (!Array.isArray(listValue)) {\r\n   listValue = [];\r\n\r\n   if (process.env.NODE_ENV !== 'production') {\r\n      warning(false,`Current value of '${prefixName.join(' > ')}' is not an array type.`);\r\n    }\r\n }\r\n```\r\n这里也很简单，对listvalue进行了一些判断，接下来是最后的一部分\r\n\r\n```js\r\n     return children(\r\n       (listValue as StoreValue[]).map((__, index): ListField => {\r\n         let key = keyManager.keys[index];\r\n         if (key === undefined) {\r\n           keyManager.keys[index] = keyManager.id;\r\n           key = keyManager.keys[index];\r\n           keyManager.id += 1;\r\n         }\r\n\r\n         return {\r\n           name: index,\r\n           key,\r\n           isListField: true,\r\n         };\r\n       }),\r\n       operations,\r\n       meta,\r\n     );\r\n```\r\n这里的children是什么呢，其实这里的children就是我们在List组件里传入的函数，这样的话就很明显了List组件帮其实就是帮我们进行了数据管理，并将操作数据的方法暴露给我们，我们再来看看最开始我们是如何使用List组件的\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d444717d4fbd4ef093f83dd6caf141e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=362&s=28328&e=png&b=f8f8f8)\r\n这里传递的filed属性其实就把这样的属性传递给了Field。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a829367ec294c9b95363a2581ac74f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=340&h=87&s=18232&e=png&b=202021)  \r\n接着我们再来看看List组件为什么能够做到对子数据的统一管理呢。  \r\n 举个简单的例子，比如我们维护了一个users的Field数组，那么他的数据结构大概是 *users:['xiaomin','xiaozhang']*,当我们通过list组件暴露出来的方法对数据进行修改时因为list组件是基于Field的封装，所以这些修改会触发onStoreChange让list组件rerender，而其中的子Field自然也会重新渲染，那么子Field是如何获取正确的值呢，看上面那张图，我们给子组件传递了一个key，在getControlled的时候，Field会调用getValue方法获取值，其实这个getValue函数就类似与lodash中的get方法，而如果一个Field是listField的话，那么当我们获取namePath时其实一种 [parentName,key] 的形式\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f7336c717643948c80631320734068~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=143&h=42&s=1501&e=png&b=fffefe)\r\n所以我们就可以根据这个获取新值达到更新的效果，这里还有一点，某个子Field的更新其实是不会影响到List组件的。\r\n### dependence\r\n最后我们再来聊一聊另一个功能，dependence.这里还是给出一个[antd的例子](https://ant.design/components/form-cn#components-form-demo-form-dependencies)，简单的说，就是我们可以给某个Flied配置dependence字段，当dependence数组中包含的Field触发了更新，这个Field也会同步触发更新。 下面是rc-field-form官方demo，大家可以自己试一下。当name为1时可以看到password渲染，然后password如果不为空则password2渲染 ，**后来在写文章的时候感觉这个例子是有问题的，我们一会再分析**\r\n\r\n```js\r\nimport Form, { Field } from 'rc-field-form';\r\nimport React from 'react';\r\nimport Input from './components/Input';\r\n\r\ntype FormData = {\r\n  name?: string;\r\n  password?: string;\r\n  password2?: string;\r\n};\r\n\r\nexport default () => {\r\n  const [form] = Form.useForm();\r\n\r\n  return (\r\n    <Form\r\n      form={form}\r\n      preserve={false}\r\n      onFieldsChange={fields => {\r\n        console.error('fields:', fields);\r\n      }}\r\n    >\r\n      <Field<FormData> name=\"name\">\r\n        <Input placeholder=\"Username\" />\r\n      </Field>\r\n\r\n      <Field<FormData> dependencies={['name']}>\r\n        {() => {\r\n          return form.getFieldValue('name') === '1' ? (\r\n            <Field name=\"password\">\r\n              <Input placeholder=\"Password\" />\r\n            </Field>\r\n          ) : null;\r\n        }}\r\n      </Field>\r\n\r\n      <Field dependencies={['password']}>\r\n        {() => {\r\n          const password = form.getFieldValue('password');\r\n          console.log('>>>', password);\r\n          return password ? (\r\n            <Field<FormData> name={['password2']}>\r\n              <Input placeholder=\"Password 2\" />\r\n            </Field>\r\n          ) : null;\r\n        }}\r\n      </Field>\r\n\r\n      <button onClick={()=} type=\"submit\">Submit</button>\r\n    </Form>\r\n  );\r\n};\r\n```\r\n这里我们直接来讲他是如何实现的,我看了一下源码然后写demo测试后发现在rc-field-form里如果我们通过如setFieldValue这样的api是无法触发dependence更新的，这里我们就只聊通过onChange等行为触发的更新。\r\n\r\n```js\r\n  private updateValue = (name: NamePath, value: StoreValue) => {\r\n  \r\n   ......\r\n\r\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\r\n   ......\r\n  };\r\n```\r\n可以看到具体的逻辑是由**updateValue**开始的，我们先来看看**triggerDependenciesUpdate**干了啥\r\n\r\n```js\r\n  private triggerDependenciesUpdate = (prevStore: Store, namePath: InternalNamePath) => {\r\n  //这个函数等会讲，其实就是拿到依赖于当前字段的Field\r\n    const childrenFields = this.getDependencyChildrenFields(namePath);\r\n    //对依赖于当前字段的Field进行校验\r\n    if (childrenFields.length) {\r\n      this.validateFields(childrenFields);\r\n    }\r\n    //通知更新\r\n    this.notifyObservers(prevStore, childrenFields, {\r\n      type: 'dependenciesUpdate',\r\n      relatedFields: [namePath, ...childrenFields],\r\n    });\r\n\r\n    return childrenFields;\r\n  };\r\n\r\n```\r\n接下来我们看看**getDependencyChildrenFields**这个方法，\r\n\r\n```js\r\n  private getDependencyChildrenFields = (rootNamePath: InternalNamePath): InternalNamePath[] => {   \r\n    const children: Set<FieldEntity> = new Set();\r\n    //返回值，这个是被打平的denpendence\r\n    const childrenFields: InternalNamePath[] = [];\r\n    //用于存储依赖的map\r\n    const dependencies2fields: NameMap<Set<FieldEntity>> = new NameMap();\r\n    \r\n    ........\r\n    \r\n    return childrenFields;\r\n  };\r\n```\r\n接下来我们来看看具体的处理，首先是构建依赖map\r\n\r\n```js\r\n    this.getFieldEntities().forEach(field => {\r\n      console.log(field.props.dependencies)\r\n      const { dependencies } = field.props;\r\n      (dependencies || []).forEach(dependency => {\r\n        const dependencyNamePath = getNamePath(dependency);\r\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\r\n          fields.add(field);\r\n          return fields;\r\n        });\r\n      });\r\n    });\r\n```\r\n举个例子，如果C和D依赖B，B依赖A，这样就会创建出这样的map来，我们为什么需要这样的操作呢，其实我们可以想一下，在这个例子中，虽然C，D的dependence是B，但是B同时也依赖于A，那么如果A触发了更新，C和D也应该更新，所以**getDependencyChildrenFields**就是为了解决这种循环依赖，现在我们已经有了dependenceMap，接下来就需要通过这个map获取所有的依赖\r\n\r\n```js\r\n{\r\n    A: [FieldB],\r\n    B: [FieldC，FieldD]\r\n}\r\n\r\n```\r\n\r\n```js\r\n    const fillChildren = (namePath: InternalNamePath) => {\r\n      //获取直接依赖于它的Field\r\n      const fields = dependencies2fields.get(namePath) || new Set();\r\n      //查看是否有Field间接依赖\r\n      fields.forEach(field => {\r\n      //只判断未判断过的\r\n        if (!children.has(field)) {\r\n          children.add(field);\r\n\r\n          const fieldNamePath = field.getNamePath();\r\n          if (fieldNamePath.length) {\r\n            childrenFields.push(fieldNamePath);\r\n            fillChildren(fieldNamePath);\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    fillChildren(rootNamePath);\r\n```\r\n这样我们就可以拿到所有依赖的Field了，我们继续回到更新的流程。\r\n\r\n```js\r\n    this.notifyObservers(prevStore, childrenFields, {\r\n      type: 'dependenciesUpdate',\r\n      relatedFields: [namePath, ...childrenFields],\r\n    });\r\n```\r\n这里已经很熟悉了，通过notifyObserver调用所有Field的onStoreChange，我们直接看在onStoreChange里进行了哪些操作\r\n\r\n```js\r\n\r\n      case 'dependenciesUpdate': {\r\n        //获取当前Field的dependence\r\n        const dependencyList = dependencies.map(getNamePath);\r\n        //如果某个依赖被包含在relatedFields中就触发更新\r\n        if (dependencyList.some(dependency => containsNamePath(info.relatedFields, dependency))) {\r\n          this.reRender();\r\n          return;\r\n        }\r\n        break;\r\n      }\r\n```\r\n其实这里也比较简单，所以dependence的流程我们也分析完了。  \r\n最后就是说说刚才我提到了官方的demo有问题，下面就来谈谈为什么有问题。还是先放一下代码\r\n\r\n```js\r\n```js\r\nimport Form, { Field } from 'rc-field-form';\r\nimport React from 'react';\r\nimport Input from './components/Input';\r\n\r\ntype FormData = {\r\n  name?: string;\r\n  password?: string;\r\n  password2?: string;\r\n};\r\n\r\nexport default () => {\r\n  const [form] = Form.useForm();\r\n\r\n  return (\r\n    <Form\r\n      form={form}\r\n      preserve={false}\r\n      onFieldsChange={fields => {\r\n        console.error('fields:', fields);\r\n      }}\r\n    >\r\n      <Field<FormData> name=\"name\">\r\n        <Input placeholder=\"Username\" />\r\n      </Field>\r\n\r\n      <Field<FormData> dependencies={['name']}>\r\n        {() => {\r\n          return form.getFieldValue('name') === '1' ? (\r\n            <Field name=\"password\">\r\n              <Input placeholder=\"Password\" />\r\n            </Field>\r\n          ) : null;\r\n        }}\r\n      </Field>\r\n\r\n      <Field dependencies={['password']}>\r\n        {() => {\r\n          const password = form.getFieldValue('password');\r\n          console.log('>>>', password);\r\n          return password ? (\r\n            <Field<FormData> name={['password2']}>\r\n              <Input placeholder=\"Password 2\" />\r\n            </Field>\r\n          ) : null;\r\n        }}\r\n      </Field>\r\n\r\n      <button onClick={()=} type=\"submit\">Submit</button>\r\n    </Form>\r\n  );\r\n};\r\n```\r\n首先，我们可以看到在官方demo中每个配置了dependence的Filed字段其实是没有配置name的，但是当我们构建childrenFields时是需要获取Field的name的，这就导致了获取childrenFields其实是获取了一个空数组，这样看来，如果当前name=1,password存在value，然后我们改变name的值，password和password1都不会隐藏，但是我们可以发现这个demo运行起来其实是没有问题的，这是为什么呢。  \r\n关键在这里：\r\n\r\n```js\r\n    this.notifyObservers(prevStore, childrenFields, {\r\n      type: 'dependenciesUpdate',\r\n      relatedFields: [namePath, ...childrenFields],\r\n    });\r\n```\r\n我们在触发dependence更新的时候在relatedFields中还把触发更新的Field name传递了过去，这里也就是'name',所以当我们触发所有组件的onStoreChange，password是能够更新的，那password1又是如何正确更新的呢？\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81e16c73048f4503b22dc41a989bde02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=828&h=262&s=141570&e=png&b=222023)\r\n还记得这个方法吗，password这个Field在卸载的时候会执行这个方法，这个方法其实就是registerField的返回函数，而这个返回函数里又调用了`this.triggerDependenciesUpdate(prevStore, namePath);`，后面的流程就跟上面相似了。  \r\n# 完结撒花\r\n写了这么多终于把rc-field-form的一些主要流程讲完了🧐，第一次写文章写的真挺烂的，最后还是大家推荐一些关于rc-field-form的文章： \r\n- [一次手写Antd Form的经历，让我受益匪浅 - 掘金 (juejin.cn)](https://juejin.cn/post/7038099720400535582)\r\n- [手写一个 Antd4 Form 吧（上篇）：源码分析 - 掘金 (juejin.cn)](https://juejin.cn/post/7116390485710602254)\r\n- [🍓中台表单技术选型实践(表单实践) - 掘金 (juejin.cn)](https://juejin.cn/post/7316723621292638246)",
      "count": "34k",
      "readingTime": "2:51",
      "imageUrls": [],
      "createdAt": null,
      "updatedAt": null,
      "modified": false
    }
  },
  "postDataList": [
    {
      "authors": [
        "zhw"
      ],
      "title": "聊聊react-scan",
      "tag": "react",
      "path": "react-scan",
      "rawFilePath": "./react-scan.md",
      "coverImage": "https://raw.githubusercontent.com/aidenybai/react-scan/ca7746e2808408c04bcfbfc15486368e67d72bba/.github/assets/logo.svg",
      "text": "# react - scan 核心原理剖析\r\n\r\nreact - scan 是一个用于监听react重渲染的工具，其核心原理是巧妙伪装成 React DevTools，借此成功接入 React 的内部运行机制，从而精准获取 Fiber 节点关键信息，实现对组件更新状况的实时监控。\r\n\r\nReact DevTools 在网页的 window 对象上会挂载一个特殊的全局对象：`__REACT_DEVTOOLS_GLOBAL_HOOK__`。React 在自身运行期间，于某些关键生命周期节点，会调用这个对象上的指定方法，像在 commit 阶段就会调用 `onCommitFiberRoot` 方法，并向其传入当前更新的 FiberRoot 节点作为参数。\r\n\r\nreact - scan 则利用这一点，通过劫持该 hook 上的函数，例如对 `onCommitFiberRoot` 进行重写操作，从而顺利获取整个 React 应用的 Fiber 树根节点。获取根节点后，借助 Fiber 节点的 child 属性指向第一个子节点、sibling 属性指向下一个兄弟节点，就能递归遍历整棵 Fiber 树，进而拿到每一个组件对应的 Fiber 节点详细信息。\r\n\r\n**如何判断组件是否发生更新？**\r\n\r\n  * 对于非 Host 组件（即非原生 DOM 节点）：通过位运算判断其 flags 与 PerformedWork 相与的结果是否为 PerformedWork，以此确定该 Fiber 节点是否发生更新。\r\n  * 对于 Host 组件（对应实际 DOM 节点）：\r\n    * 若不存在 alternate 节点，表明是组件的首次渲染（因为 Fiber 采用双缓冲机制，存在当前树与上一次树之分）。\r\n    * 若存在 alternate 节点，则对比当前与上一次的 memoizedProps（组件属性）、memoizedState（组件状态）、ref，判断组件是否更新。\r\n\r\n**如何定位更新组件的 DOM 元素？**\r\n\r\n一旦确定组件发生更新，可以从对应的 Fiber 节点向上查找最近的 Host 节点（即 Host Fiber），获取其关联的 DOM 元素，进而对 DOM 元素进行高亮或标记操作，方便进行调试或可视化展示。\r\n\r\n**一些其他功能：**\r\n\r\n  * 对比两棵 Fiber 树的 memoizedProps，能够精确知晓具体哪个 prop 发生了变化。\r\n  * 判断是否因 Context 变化引发的组件更新：可通过 fiber.firstContext 获取组件订阅的第一个 Context，然后凭借其 next 属性依次遍历所有订阅的 Context 节点，查找更新源头。\r\n  * 判断是否因为 Hook 更新导致组件更新：鉴于 Fiber 上的 memoizedState 存储着 hooks 链表，可据此分析是哪个 state 发生了变化。",
      "count": "1.1k",
      "readingTime": "5 ",
      "imageUrls": [],
      "createdAt": "2025-05-09T10:11:35.000Z",
      "updatedAt": "2025-05-09T10:11:35.000Z",
      "modified": false
    },
    {
      "authors": [
        "zhw"
      ],
      "title": "建站",
      "tag": "生活",
      "path": "first",
      "rawFilePath": "./first.md",
      "coverImage": "https://upload-bbs.miyoushe.com/upload/2024/07/27/75276539/98580c852764d70e5a9597aa7678f131_2245446554692880272.jpg",
      "text": "记录一下建站的第一天,也许开心到爆炸.\r\n![建站图片](https://upload-bbs.miyoushe.com/upload/2024/07/27/75276539/98580c852764d70e5a9597aa7678f131_2245446554692880272.jpg)\r\n![建站图片](https://upload-bbs.miyoushe.com/upload/2024/03/20/285532152/757fa74f8b38fdfab0bd1b653a69af4d_6553329811603610700.gif)\r\n",
      "count": "268",
      "readingTime": "1 ",
      "imageUrls": [
        "https://upload-bbs.miyoushe.com/upload/2024/07/27/75276539/98580c852764d70e5a9597aa7678f131_2245446554692880272.jpg",
        "https://upload-bbs.miyoushe.com/upload/2024/03/20/285532152/757fa74f8b38fdfab0bd1b653a69af4d_6553329811603610700.gif"
      ],
      "createdAt": "2024-11-13T12:48:31.000Z",
      "updatedAt": "2024-11-14T08:12:55.000Z",
      "modified": true
    },
    {
      "authors": [
        "zhw"
      ],
      "title": "rc-field-form源码分析",
      "tag": "react",
      "path": "rc-field-form",
      "rawFilePath": "./rc-field-form.md",
      "coverImage": "https://avatars.githubusercontent.com/u/9441414?s=48&v=4",
      "text": "本篇文章将简单分析rc-field-form的源码，rc-field-form是一个react表单管理解决方案，antd的form就是基于他进行的封装，如果大家想要了解react表单的主流解决方案，可以阅读[🍓中台表单技术选型实践(表单实践) - 掘金 (juejin.cn)](https://juejin.cn/post/7316723621292638246#heading-13)\r\n## 用法\r\n首先我们来看看rc-field-form的用法\r\n\r\n```js\r\nimport Form, { useForm, Field } from \"../rc-form\";\r\n\r\nexport default () => {\r\n  const [form] = useForm();\r\n\r\n  return (\r\n    <Form\r\n      onFinish={(e) => {\r\n        console.log(e);\r\n      }}\r\n      onFinishFailed={(e) => {\r\n        console.log(e);\r\n      }}\r\n      form={form}\r\n    >\r\n      <Field name=\"name\" rules={[{ required: true, max: 4 }]}>\r\n        <input placeholder=\"Username\" />\r\n      </Field>\r\n      <Field name=\"password\" rules={[{ required: true, max: 1 }]}>\r\n        <input placeholder=\"Username1\" />\r\n      </Field>\r\n      <button>Submit</button>\r\n    </Form>\r\n  );\r\n};\r\n\r\n```\r\n在这段代码中，使我们使用 Form 组件来新建一个 Form 表单，然后在Field组件里包裹了我们的每一个表单项，并且通过Field的name字段创建表单的key，rules来配置校验。当我们点击button后，会根据是否通过校验来触发onFinsh或者onFinishFailed。\r\n\r\n由此我们可以引出一些问题：\r\n- Form组件是如何管理我们的表单数据\r\n- 我们并没有给每个input绑定事件，表单的值是如何更新的\r\n- Form组件如何对我们的数据进行校验\r\n下面就让我们从源码入手来解决这些问题\r\n# **一**·如何实现数据的更新\r\n### Form组件如何管理数据\r\n根据上面的代码，当我们创建Form组件时，必须要给Form组件传入一个通过useForm这个hook得到的form，那么这个form是什么呢？下面是useForm的源码\r\n\r\n```js\r\nfunction useForm(form) {\r\n  const formRef = React.useRef();\r\n  const [, forceUpdate] = React.useState({});\r\n\r\n  if (!formRef.current) {\r\n    if (form) {\r\n      formRef.current = form;\r\n    } else {\r\n      // Create a new FormStore if not provided\r\n      const forceReRender = () => {\r\n        forceUpdate({});\r\n      };\r\n\r\n      const formStore: FormStore = new FormStore(forceReRender);\r\n\r\n      formRef.current = formStore.getForm();\r\n    }\r\n  }\r\n\r\n  return [formRef.current];\r\n}\r\n\r\n```\r\n当我们在使用useForm的时候，我们一般不会传入form参数，那么这个hook就会帮我们new一个FormStore，FormStore是一个很重要的类，整个表单数据的存储和操作方法都是由他提供，然后返回Formstore的getForm方法，其实这里就是通过getForm将Formstore里的一些属性和方法暴露了出来。\r\n我们先来简单看下FormStore里都有啥(只展示部分属性和方法)\r\n\r\n```js\r\nexport class FormStore {\r\n  //new FormStore时传入的setState方法\r\n  private forceRootUpdate\r\n\r\n  private subscribabl = true;\r\n//整个表单的数据\r\n  private store: Store = {};\r\n//每个Field组件都会被注册到这个数组里\r\n  private fieldEntities = [];\r\n//初始值\r\n  private initialValues = {};\r\n//存放Form上的onFinish等方法\r\n  private callbacks: Callbacks = {};\r\n  \r\n  constructor(forceRootUpdate: () => void) {\r\n    this.forceRootUpdate = forceRootUpdate;\r\n  }\r\n  //暴露出去给开发者的一些方法\r\n   public getForm = (): InternalFormInstance => ({\r\n    getFieldValue: this.getFieldValue,\r\n    getFieldsValue: this.getFieldsValue,\r\n    getFieldWarning: this.getFieldWarning,\r\n    resetFields: this.resetFields,\r\n    setFields: this.setFields,\r\n    setFieldValue: this.setFieldValue,\r\n    setFieldsValue: this.setFieldsValue,\r\n    validateFields: this.validateFields,\r\n    submit: this.submit,\r\n    getInternalHooks: this.getInternalHooks,\r\n    ......\r\n  });\r\n    private getInternalHooks = (key: string): InternalHooks | null => {\r\n    //只提供给内部组件的方法，开发者在其他组件无法调用，这里的HOOK_MAR是Field组件通过context获得的\r\n    if (key === HOOK_MARK) {\r\n      this.formHooked = true;\r\n\r\n      return {\r\n        dispatch: this.dispatch,\r\n        initEntityValue: this.initEntityValue,\r\n        registerField: this.registerField,\r\n        useSubscribe: this.useSubscribe,\r\n        setInitialValues: this.setInitialValues,\r\n        destroyForm: this.destroyForm,\r\n        setCallbacks: this.setCallbacks,\r\n        setValidateMessages: this.setValidateMessages,\r\n        getFields: this.getFields,\r\n        setPreserve: this.setPreserve,\r\n        getInitialValue: this.getInitialValue,\r\n        registerWatch: this.registerWatch,\r\n      };\r\n    }\r\n\r\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\r\n    return null;\r\n  };\r\n```\r\n还有很多方法感觉太多了这里没有列举，我们直接按流程进行分析理解，上面我们讲到了Form组件需要传入form，而form是FormStore通过getForm暴露出的一些属性和方法接下来我们来看看Form组件是如何消费form的\r\n\r\n\r\n```js\r\n//formcontext是用于全局form管理的暂不分析\r\nconst formContext: FormContextProps = React.useContext(FormContext);\r\n//拿到FormStore暴露的属性，方法\r\n  const [formInstance] = useForm(form);\r\n  const {\r\n    useSubscribe,\r\n    setInitialValues,\r\n    setCallbacks,\r\n    setValidateMessages,\r\n    setPreserve,\r\n    destroyForm,\r\n  } = (formInstance as InternalFormInstance).getInternalHooks(HOOK_MARK);\r\n\r\n  // 转发ref让外部可以通过ref调用\r\n  React.useImperativeHandle(ref, () => formInstance);\r\n\r\n  //全局管理有关\r\n  React.useEffect(() => {\r\n    formContext.registerForm(name, formInstance);\r\n    return () => {\r\n      formContext.unregisterForm(name);\r\n    };\r\n  }, [formContext, formInstance, name]);\r\n\r\n  //设置validateMessage\r\n  setValidateMessages({\r\n    ...formContext.validateMessages,\r\n    ...validateMessages,\r\n  });\r\n  //注册form表单上传入的方法\r\n  setCallbacks({\r\n    onValuesChange,\r\n    onFieldsChange: (changedFields: FieldData[], ...rest) => {\r\n      formContext.triggerFormChange(name, changedFields);\r\n\r\n      if (onFieldsChange) {\r\n        onFieldsChange(changedFields, ...rest);\r\n      }\r\n    },\r\n    onFinish: (values: Store) => {\r\n      formContext.triggerFormFinish(name, values);\r\n\r\n      if (onFinish) {\r\n        onFinish(values);\r\n      }\r\n    },\r\n    onFinishFailed,\r\n  });\r\n  setPreserve(preserve);\r\n```\r\n大概就是为FormStore初始化一些东西，对主流程影响不大，我们继续看，下面来到了创建初始值\r\n\r\n```js\r\n//判断是否为首次渲染，首次渲染就创建初始值\r\n  const mountRef = React.useRef(null);\r\n  setInitialValues(initialValues, !mountRef.current);\r\n  if (!mountRef.current) {\r\n    mountRef.current = true;\r\n  }\r\n//每次重新渲染时重置Form\r\n  React.useEffect(\r\n    () => destroyForm,\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [],\r\n  );\r\n\r\n```\r\n我们先来看setInitialValues这个方法\r\n\r\n```js\r\n  private setInitialValues = (initialValues: Store, init: boolean) => {\r\n    this.initialValues = initialValues || {};\r\n    if (init) {\r\n    //merge方法是rc-util提供的工具函数，rc-field-form里的很多操作都用到了里面的函数，这里不做分析\r\n      let nextStore = merge(initialValues, this.store);\r\n    //非主要流程跳过\r\n      this.prevWithoutPreserves?.map(({ key: namePath }) => {\r\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\r\n      });\r\n      this.prevWithoutPreserves = null;\r\n\r\n      this.updateStore(nextStore);\r\n    }\r\n  };\r\n```\r\n我们可以看到setinitalValues方法最后调用了updateStore，这个方法很简单\r\n\r\n```js\r\n  private updateStore = (nextStore: Store) => {\r\n    this.store = nextStore;\r\n  };\r\n```\r\n直接修改了store，接下来是对child不同type的一些处理\r\n\r\n```js\r\n  let childrenNode: React.ReactNode;\r\n  const childrenRenderProps = typeof children === 'function';\r\n  if (childrenRenderProps) {\r\n    const values = formInstance.getFieldsValue(true);\r\n    childrenNode = (children as RenderProps)(values, formInstance);\r\n  } else {\r\n    childrenNode = children;\r\n  }\r\n```\r\n如果child是一个函数，则传入childNode为函数返回值,这里的getFieldsValue方法参数为true时返回的就是整个store，也可以传入Field的name数组获取指定的value，具体实现不做分析。继续继续😊\r\n\r\n```js\r\nconst formContextValue = React.useMemo(\r\n    () => ({\r\n      ...(formInstance as InternalFormInstance),\r\n      validateTrigger,\r\n    }),\r\n    [formInstance, validateTrigger],\r\n  );\r\n```\r\n然后我们创建了一个context，传入formInstance(FormStore暴露的方法和数据)，还有一个validateTrigger，这个我们之前没有提到，这个属性是用户传给Form组件的，他的默认值是onChange,也就是说在onChange的时候会触发Field组件的validate。马上就到尾声了(其实是Form的尾声，后面还有一堆)\r\n\r\n```js\r\n  const wrapperNode = (\r\n    <ListContext.Provider value={null}>\r\n      <FieldContext.Provider value={formContextValue}>{childrenNode}</FieldContext.Provider>\r\n    </ListContext.Provider>\r\n  );\r\n```\r\n接下创建一个wrapperNode，其实就是一个contextProvider，ListContext.Provider这个应该是为List组件服务的我们暂不关心，然后我们可以看到FieldContext.Provider就是提供了formInstance和validateTrigger，这样我们的Field组件也可以访问和操作formInstance啦。\r\n然后就是我们最后的代码\r\n\r\n```js\r\n  if (Component === false) {\r\n    return wrapperNode;\r\n  }\r\n\r\n  return (\r\n    <Component\r\n      {...restProps}\r\n      onSubmit={(event: React.FormEvent<HTMLFormElement>) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        formInstance.submit();\r\n      }}\r\n      onReset={(event: React.FormEvent<HTMLFormElement>) => {\r\n        event.preventDefault();\r\n\r\n        formInstance.resetFields();\r\n        restProps.onReset?.(event);\r\n      }}\r\n    >\r\n      {wrapperNode}\r\n    </Component>\r\n  );\r\n};\r\n```\r\n这里的Component也是由用户传入的，默认值为'form'，所以最后的效果其实是\r\n```js    \r\n    <form\r\n      {...restProps}\r\n      onSubmit={(event: React.FormEvent<HTMLFormElement>) => {\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        formInstance.submit();\r\n      }}\r\n      onReset={(event: React.FormEvent<HTMLFormElement>) => {\r\n        event.preventDefault();\r\n\r\n        formInstance.resetFields();\r\n        restProps.onReset?.(event);\r\n      }}\r\n    >\r\n      {wrapperNode}\r\n    </form>\r\n```\r\n这里阻止了一下form的默认行为，然后会在submit和reset时执行formInstance的方法。\r\n\r\n到这里我们先总结一下，Form组件都干了什么\r\n- 首先他拿到了form然后setCallbacks，setInitialValues对forminstance的callback和store进行了初始化\r\n- 然后对children进行了处理，用FieldContext将它包裹，让Field组件可以拿到formInstance等一些东西\r\n- 最后用form标签将处理后的child包裹起来，将事件进行绑定\r\n### Field如何消费数据\r\n接下来让我们继续看看Feld组件，Field组件有一点特殊，他是一个class组件🤔，源码中注释是\r\n` We use Class instead of Hooks here since it will cost much code by using Hooks.`大概意思是通过class组件的方式实现可以减少代码量。我们先来看看Field组件大致的代码结构。\r\n```js\r\nclass Field extends React.Component<InternalFieldProps, FieldState> implements FieldEntity {\r\n    //传入的formInstance\r\n    public static contextType = FieldContext;\r\n    //组件默认参数\r\n    public static defaultProps\r\n    //定义一个state用于触发rerender\r\n    public state \r\n    //用于组件卸载时清除formInstance里数据\r\n    private cancelRegisterFunc\r\n    //是否已挂载\r\n    private mounted = false;\r\n    //表单校验结果的Promise\r\n    private validatePromise\r\n    //校验结果error\r\n    private errors\r\n    //校验结果 warning\r\n    private warnings\r\n  \r\n    constructor(props) {\r\n        super()\r\n        ..........\r\n    }\r\n  \r\n    public componentDidMount\r\n  \r\n    public componentWillUnmount() {\r\n    }\r\n    //会调用并销毁cancelRegisterFunc\r\n    public cancelRegister\r\n    //获取Field的name\r\n    public getNamePath\r\n    //获取传入的rules\r\n    public getRules\r\n    //用于更新组件\r\n    public reRender\r\n    public refresh\r\n    // ========================= 这个方法很重要，跟组件更新相关 ==============================\r\n    public onStoreChange\r\n    //校验rulues的方法\r\n    public validateRules\r\n    public isFieldValidating = () => !!this.validatePromise;\r\n   //获取校验后的结果\r\n    public getErrors\r\n    public getWarnings\r\n   //对传入的child的一些处理\r\n    public getOnlyChild\r\n    //返回当前Field字段的值\r\n    public getValue\r\n    // ======== 就是这个方法让我们传入的组件受控，劫持了组件的onChange这类事件 ====================\r\n    public getControlled\r\n    //返回处理后的子组件\r\n    public render() {\r\n    \r\n    }\r\n  }\r\n```\r\n了解了大体结构，接下来我们先从constructor入手，看看Field组件的渲染流程。\r\n\r\n```js\r\n  constructor(props: InternalFieldProps) {\r\n    super(props);\r\n\r\n    // Register on init\r\n    if (props.fieldContext) {\r\n      const { getInternalHooks }: InternalFormInstance = props.fieldContext;\r\n      const { initEntityValue } = getInternalHooks(HOOK_MARK);\r\n      initEntityValue(this);\r\n    }\r\n  }\r\n\r\n```\r\n这里其实就是调用了initEntityValue这个函数，传入Field组件\r\n\r\n```js\r\n private initEntityValue = (entity: FieldEntity) => {\r\n    const { initialValue } = entity.props;\r\n\r\n    if (initialValue !== undefined) {\r\n      const namePath = entity.getNamePath();\r\n      const prevValue = getValue(this.store, namePath);\r\n\r\n      if (prevValue === undefined) {\r\n        this.updateStore(setValue(this.store, namePath, initialValue));\r\n      }\r\n    }\r\n  };\r\n```\r\n这里就是简单设置了一下初始值并不会引起Field的rerender，接下来我们继续看Field组件都做了哪些初始化\r\n\r\n```js\r\n  public componentDidMount() {\r\n    const {  fieldContext } = this.props;\r\n     //标记为已挂载\r\n    this.mounted = true;\r\n\r\n    if (fieldContext) {\r\n      const { getInternalHooks }: InternalFormInstance = fieldContext;\r\n      const { registerField } = getInternalHooks(HOOK_MARK);\r\n      //\r\n      this.cancelRegisterFunc = registerField(this);\r\n    }\r\n  }\r\n```\r\n这里的核心就是registerField，还记得我们之前提到过formStore的fieldEntities数组里存储了Field吗，这个函数其实核心就是fieldEntities.push(field)，然后给我们返回了一个函数用于在fieldEntities里delete这个Field，这样我们就可以通过formInstance调用Field里暴露的一些方法用于更新或者校验。 \r\n\r\n然后就是render函数\r\n\r\n```js\r\n public render() {\r\n    const { resetCount } = this.state;\r\n    const { children } = this.props;\r\n\r\n    const { child, isFunction } = this.getOnlyChild(children);\r\n\r\n    // Not need to `cloneElement` since user can handle this in render function self\r\n    let returnChildNode: React.ReactNode;\r\n    if (isFunction) {\r\n      returnChildNode = child;\r\n    } else if (React.isValidElement(child)) {\r\n      returnChildNode = React.cloneElement(\r\n        child as React.ReactElement,\r\n        this.getControlled((child as React.ReactElement).props),\r\n      );\r\n    } else {\r\n      warning(!child, '`children` of Field is not validate ReactElement.');\r\n      returnChildNode = child;\r\n    }\r\n\r\n    return <React.Fragment key={resetCount}>{returnChildNode}</React.Fragment>;\r\n  }\r\n}\r\n```\r\ngetonlychild返回第一个child和他的类型，当child是合法的reactElement时，调用[cloneElement方法](https://react.dev/reference/react/cloneElement)，然后返回Fragment包裹的cloneElement，所以这里的关键就是这个cloneElement的第二个参数，这里到底传入了什么东西🤨。  \r\n简单地说，cloneElement的第二个参数其实是`props`，它可以覆盖默认的props，fc-field-form就是在这里接管了Field的onChange等一系列事件，我们来看看getControlled的源码\r\n\r\n```js\r\n  public getControlled = (childProps: ChildProps = {}) => {\r\n  //获取Field的一些方法和数据\r\n    const {\r\n      name,\r\n      trigger,\r\n      validateTrigger,\r\n      getValueFromEvent,\r\n      normalize,\r\n      valuePropName,\r\n      getValueProps,\r\n      fieldContext,\r\n    } = this.props;\r\n   //校验有关,其实就是一些事件的name，如'onChange'\r\n    const mergedValidateTrigger =\r\n      validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\r\n    //当前field name\r\n    const namePath = this.getNamePath();\r\n    const { getInternalHooks, getFieldsValue }: InternalFormInstance = fieldContext;\r\n    //---------- dispatch传入不同的参数可以分发不同操作如校验，更新 ----------------\r\n    const { dispatch } = getInternalHooks(HOOK_MARK);\r\n    const value = this.getValue();\r\n    //不太重要，给子元素提供一个可以获取value的方法\r\n    const mergedGetValueProps = getValueProps || ((val: StoreValue) => ({ [valuePropName]: val }));\r\n    //同上\r\n    const valueProps = name !== undefined ? mergedGetValueProps(value) : {};\r\n        //trigger的默认值是onChange，如果我们在某个Field的input里绑定了onChange事件，这里就可以拿到\r\n    const originTriggerFunc = childProps[trigger];\r\n    // warning when prop value is function\r\n    if (process.env.NODE_ENV !== 'production' && valueProps) {\r\n      Object.keys(valueProps).forEach(key => {\r\n        warning(\r\n          typeof valueProps[key] !== 'function',\r\n          `It's not recommended to generate dynamic function prop by \\`getValueProps\\`. Please pass it to child component directly (prop: ${key})`,\r\n        );\r\n      });\r\n    }\r\n    //这个control就是我们要返回的props，现在还几乎没有啥真正有用的变化\r\n    const control = {\r\n      ...childProps,\r\n      ...valueProps,\r\n    };\r\n    //------------------------------- 劫持事件了 ------------------------------------\r\n    control[trigger] = (...args: EventArgs) => {\r\n      //修改一些状态\r\n      this.touched = true;\r\n      this.dirty = true;\r\n\r\n      this.triggerMetaEvent();\r\n\r\n      let newValue: StoreValue;\r\n      //默认为空，用户可以传入，就是获取事件返回值\r\n      if (getValueFromEvent) {\r\n        newValue = getValueFromEvent(...args);\r\n      } else {\r\n      //用户不传入使用默认方法\r\n        newValue = defaultGetValueFromEvent(valuePropName, ...args);\r\n      }\r\n      //对数据进行一些格式化处理\r\n      if (normalize) {\r\n        newValue = normalize(newValue, value, getFieldsValue(true));\r\n      }\r\n       //分发更新事件\r\n      dispatch({\r\n        type: 'updateValue',\r\n        namePath,\r\n        value: newValue,\r\n      });\r\n       //如果用户还绑定了事件，调用用户原来绑定的事件\r\n      if (originTriggerFunc) {\r\n        originTriggerFunc(...args);\r\n      }\r\n    };\r\n    \r\n    //触发校验的数组，如['onChange'],后面的先不看属于校验的内容\r\n     const validateTriggerList: string[] = toArray(mergedValidateTrigger || []);\r\n\r\n    validateTriggerList.forEach((triggerName: string) => {\r\n      // Wrap additional function of component, so that we can get latest value from store\r\n      const originTrigger = control[triggerName];\r\n      control[triggerName] = (...args: EventArgs) => {\r\n        if (originTrigger) {\r\n          originTrigger(...args);\r\n        }\r\n\r\n        // Always use latest rules\r\n        const { rules } = this.props;\r\n        if (rules && rules.length) {\r\n          // We dispatch validate to root,\r\n          // since it will update related data with other field with same name\r\n          dispatch({\r\n            type: 'validateField',\r\n            namePath,\r\n            triggerName,\r\n          });\r\n        }\r\n      };\r\n    });\r\n\r\n    return control;\r\n  };\r\n```\r\n到了这里其实我们已经找到了rc-field-form在表单触发事件时，虽然我们并没有绑定事件，但是它已经将其劫持，并且通过dispatch这个函数通知formStore进行数据上的更新。接下来我们一起来探索data和ui是如何更新。\r\n\r\ndispatch这个函数的代码很少，如下\r\n```js\r\n  private dispatch = (action: ReducerAction) => {\r\n    switch (action.type) {\r\n      case 'updateValue': {\r\n        const { namePath, value } = action;\r\n        this.updateValue(namePath, value);\r\n        break;\r\n      }\r\n      case 'validateField': {\r\n        const { namePath, triggerName } = action;\r\n        this.validateFields([namePath], { triggerName });\r\n        break;\r\n      }\r\n      default:\r\n      // Currently we don't have other action. Do nothing.\r\n    }\r\n  };\r\n```\r\n可以看到，我们触发updateVlue进入了updateValue这个函数\r\n\r\n```js\r\n  private updateValue = (name: NamePath, value: StoreValue) => {\r\n    const namePath = getNamePath(name);\r\n    const prevStore = this.store;\r\n    this.updateStore(setValue(this.store, namePath, value));\r\n\r\n    this.notifyObservers(prevStore, [namePath], {\r\n      type: 'valueUpdate',\r\n      source: 'internal',\r\n    });\r\n    ......\r\n  };\r\n```\r\n 简略后的代码如上，updateStore更新了一下store，其实到这里我们就已经将formInstance的store更新了，接下来思考的是如何更新ui，我们一起来看看这个notifyObservers函数\r\n \r\n```js\r\n private notifyObservers = (\r\n    prevStore: Store,\r\n    namePathList: InternalNamePath[] | null,\r\n    info: NotifyInfo,\r\n  ) => {\r\n    if (this.subscribable) {\r\n    //合并info和store\r\n      const mergedInfo: ValuedNotifyInfo = {\r\n        ...info,\r\n        store: this.getFieldsValue(true),\r\n      };\r\n      //获取所有Field，执行每个Field的onStoreChange方法\r\n      this.getFieldEntities().forEach(({ onStoreChange }) => {\r\n        onStoreChange(prevStore, namePathList, mergedInfo);\r\n      });\r\n    } else {\r\n      this.forceRootUpdate();\r\n    }\r\n  };\r\n```\r\n还记得我们提到过Field里的onStoreChange与更新有关吗，没错现在这一切都连了起来。\r\n\r\n```js\r\npublic onStoreChange: FieldEntity['onStoreChange'] = (prevStore, namePathList, info) => {\r\n  const { shouldUpdate, dependencies = [], onReset } = this.props;\r\n  const { store } = info;\r\n  const namePath = this.getNamePath();\r\n  const prevValue = this.getValue(prevStore);\r\n  const curValue = this.getValue(store);\r\n  //匹配是否包含当前name\r\n  const namePathMatch = namePathList && containsNamePath(namePathList, namePath);\r\n\r\n  // 为setFieldValue这样的api服务的\r\n  if (\r\n    info.type === 'valueUpdate' &&\r\n    info.source === 'external' &&\r\n    !isEqual(prevValue, curValue)\r\n  ) {\r\n    this.touched = true;\r\n    this.dirty = true;\r\n    this.validatePromise = null;\r\n    this.errors = EMPTY_ERRORS;\r\n    this.warnings = EMPTY_ERRORS;\r\n    this.triggerMetaEvent();\r\n  }\r\n  //其他代码省略，我们这里是default\r\n  switch (info.type) {\r\n    case 'reset':\r\n    case 'remove':\r\n    case 'setField':\r\n    case 'dependenciesUpdate'\r\n    default:\r\n    //一些是否需要更新的判断\r\n      if (\r\n        namePathMatch ||\r\n        ((!dependencies.length || namePath.length || shouldUpdate) &&\r\n          requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info))\r\n      ) {\r\n      //调用方法更新\r\n        this.reRender();\r\n        return;\r\n      }\r\n      break;\r\n  }\r\n\r\n  if (shouldUpdate === true) {\r\n    this.reRender();\r\n  }\r\n  };\r\n```\r\nrerender方法也很简单，就是使用了类组件的forceUpdate强制更新\r\n```js\r\n  public reRender() {\r\n    if (!this.mounted) return;\r\n    this.forceUpdate();\r\n  }\r\n```\r\n到这里，我们已经知道了表单如何进行最基本的更新，这里放一张字节大佬的图\r\n\r\n![64652037b3ee4d1184d79e8e105e2429~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75[1].awebp](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a88f033593474fd58c47fa0bc79d781c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1588&h=778&s=46900&e=webp&b=fffefe)\r\n再理一下思路\r\n1. 首先我们在Form组件中创建了formInstance,将初始值和一些callback绑定到了form上，然后通过FieldContext将formInstance下放到每个Field组件里实现了方法和数据的共享\r\n2. 在Field组件中，它会在componentDidMount阶段被注册到formInstance中，然后我们通过cloneElement这个api对传入Field的子组件的事件进行了劫持，当触发某生事件时Field组件调用formInstance的dispath方法开始触发更新\r\n3. dispath根据不同的action type会派发不同的事件，在updateVlue的情况下调用了updateValue方法，这个方法中首先通过updateStore方法对Store中的数据进行了更新，然后调用notifyObserver方法，notifyObserver会遍历所有Field组件，调用他们的onStorechange方法，每个Field组件会判断是否需要更新和更新的类型(如reset,setField),然后据此进行不同的操作，最后更新的方法是refresh()，其实就是调用了类组件的forceUpdate方法  \r\n\r\n上面这种更新方式是通过用户的一些行为，我们也可以通过forminstance暴露的一些方法如setFieldsValue对表单进行更新，我们再来看看这是如何做到的\r\n\r\n```js\r\nprivate setFieldsValue = (store: Store) => {\r\n  //防止用户在form组件外使用\r\n  this.warningUnhooked();\r\n\r\n  const prevStore = this.store;\r\n  //更新store数据\r\n  if (store) {\r\n    const nextStore = merge(this.store, store);\r\n    this.updateStore(nextStore);\r\n  }\r\n//还是通过notifyObservers触发所有Field的onStorechange\r\n  this.notifyObservers(prevStore, null, {\r\n    type: 'valueUpdate',\r\n    source: 'external',\r\n  });\r\n  ......\r\n};\r\n```\r\n最后走到onStorechange的代码\r\n\r\n```js\r\ncase 'setField': {\r\n  const { data } = info;\r\n  if (namePathMatch) {\r\n    if ('touched' in data) {\r\n      this.touched = data.touched;\r\n    }\r\n    if ('validating' in data && !('originRCField' in data)) {\r\n      this.validatePromise = data.validating ? Promise.resolve([]) : null;\r\n    }\r\n    if ('errors' in data) {\r\n      this.errors = data.errors || EMPTY_ERRORS;\r\n    }\r\n    if ('warnings' in data) {\r\n      this.warnings = data.warnings || EMPTY_ERRORS;\r\n    }\r\n    this.dirty = true;\r\n\r\n    this.triggerMetaEvent();\r\n\r\n    this.reRender();\r\n    return;\r\n  } else if ('value' in data && containsNamePath(namePathList, namePath, true)) {\r\n          // Contains path with value should also check\r\n    this.reRender();\r\n    return;\r\n  }\r\n```\r\n只是多了一些数据的处理，其他代码都差不多，到这里form的更新大概就聊完了，接下来我们来说说表单校验是如何实现的。\r\n# 二·如何实现校验\r\n### 如何触发校验\r\n想要知道校验的实现，我们还是得先看看有哪些方法可以触发form表单的校验，首先是formInstance的submit\r\n\r\n```js\r\nprivate submit = () => {\r\n  this.warningUnhooked();\r\n//这个就是校验相关的函数\r\n  this.validateFields()\r\n    .then(values => {\r\n      const { onFinish } = this.callbacks;\r\n      if (onFinish) {\r\n        try {\r\n          onFinish(values);\r\n        } catch (err) {\r\n          // Should print error if user `onFinish` callback failed\r\n          console.error(err);\r\n        }\r\n      }\r\n    })\r\n    .catch(e => {\r\n      const { onFinishFailed } = this.callbacks;\r\n      if (onFinishFailed) {\r\n        onFinishFailed(e);\r\n      }\r\n    });\r\n};\r\n}\r\n```\r\n还有当一些用户行为触发的事件如onChange，其实这也是在getControlled里帮我们劫持了\r\n\r\n```js\r\n\r\n  ...\r\n  //触发校验的event name数组\r\n const validateTriggerList: string[] = toArray(mergedValidateTrigger || []);\r\n\r\n validateTriggerList.forEach((triggerName: string) => {\r\n   // Wrap additional function of component, so that we can get latest value from store\r\n   const originTrigger = control[triggerName];\r\n   //劫持并添加校验逻辑\r\n   control[triggerName] = (...args: EventArgs) => {\r\n     if (originTrigger) {\r\n       originTrigger(...args);\r\n     }\r\n\r\n     // 如果存在rules就dispatch派发校验\r\n     const { rules } = this.props;\r\n     if (rules && rules.length) {\r\n       // We dispatch validate to root,\r\n       // since it will update related data with other field with same name\r\n       dispatch({\r\n         type: 'validateField',\r\n         namePath,\r\n         triggerName,\r\n       });\r\n     }\r\n```\r\n这里的dispatch也会触发formInstance的validateFields方法，下面我们就把注意力放到这个函数中\r\n### 校验的实现\r\n\r\n```js\r\nprivate validateFields: InternalValidateFields = (arg1?: any, arg2?: any) => {\r\n  this.warningUnhooked();\r\n\r\n  let nameList: NamePath[];\r\n  let options: InternalValidateOptions;\r\n  //对不同形式传入参数的一些处理\r\n  if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\r\n    nameList = arg1;\r\n    options = arg2;\r\n  } else {\r\n    options = arg1;\r\n  }\r\n  //获取传入的Field name\r\n  const provideNameList = !!nameList;\r\n  const namePathList: InternalNamePath[] | undefined = provideNameList\r\n    ? nameList.map(getNamePath)\r\n    : [];\r\n\r\n  // 用来收集后续的校验\r\n  const promiseList: Promise<FieldError>[] = [];\r\n\r\n  //遍历每个Field判断是否需要校验\r\n  this.getFieldEntities(true).forEach((field: FieldEntity) => {\r\n    // 如果没有传入namelist就把所有Field加入namePathList中\r\n    if (!provideNameList) {\r\n      namePathList.push(field.getNamePath());\r\n    }\r\n\r\n    // 如果没有配置rule就不需要后续操作\r\n    if (!field.props.rules || !field.props.rules.length) {\r\n      return;\r\n    }\r\n\r\n    const fieldNamePath = field.getNamePath();\r\n \r\n\r\n    //调用Field的校验方法，保存该方法的Promise\r\n    if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\r\n      const promise = field.validateRules({\r\n        validateMessages: {\r\n          ...defaultValidateMessages,\r\n          ...this.validateMessages,\r\n        },\r\n        ...options,\r\n      });\r\n\r\n      // 将保存的Promise推入之前创建的promiseList中\r\n      promiseList.push(\r\n        promise\r\n          .then<any, RuleError>(() => ({ name: fieldNamePath, errors: [], warnings: [] }))\r\n          .catch((ruleErrors: RuleError[]) => {\r\n          //保留错误和warnings\r\n            const mergedErrors: string[] = [];\r\n            const mergedWarnings: string[] = [];\r\n            //根据传入的不同配置对错误进行不同处理         \r\n            ruleErrors.forEach?.(({ rule: { warningOnly }, errors }) => {\r\n              if (warningOnly) {\r\n                mergedWarnings.push(...errors);\r\n              } else {\r\n                mergedErrors.push(...errors);\r\n              }\r\n            });\r\n             //根据是否有错误返回不同结果\r\n            if (mergedErrors.length) {\r\n              return Promise.reject({\r\n                name: fieldNamePath,\r\n                errors: mergedErrors,\r\n                warnings: mergedWarnings,\r\n              });\r\n            }\r\n\r\n            return {\r\n              name: fieldNamePath,\r\n              errors: mergedErrors,\r\n              warnings: mergedWarnings,\r\n            };\r\n          }),\r\n      );\r\n      }\r\n  });\r\n   //收集所有检验项的结果\r\n  const summaryPromise = allPromiseFinish(promiseList);\r\n    //将这次校验的结果保存在formInstance中\r\n  this.lastValidatePromise = summaryPromise;\r\n\r\n  // Notify fields with rule that validate has finished and need update\r\n  summaryPromise\r\n    .catch(results => results)\r\n    .then((results: FieldError[]) => {\r\n      const resultNamePathList: InternalNamePath[] = results.map(({ name }) => name);\r\n      //通知Field进行更新\r\n      this.notifyObservers(this.store, resultNamePathList, {\r\n        type: 'validateFinish',\r\n      });\r\n      this.triggerOnFieldsChange(resultNamePathList, results);\r\n    });\r\n    //这个Promise将会被作为返回值，在submit的时候会起到作用\r\n  const returnPromise: Promise<Store | ValidateErrorEntity | string[]> = summaryPromise\r\n    .then((): Promise<Store | string[]> => {\r\n    //如果没有规则错误就直接返回所有校验项的值\r\n      if (this.lastValidatePromise === summaryPromise) {\r\n        return Promise.resolve(this.getFieldsValue(namePathList));\r\n      }\r\n      return Promise.reject<string[]>([]);\r\n    })\r\n    .catch((results: { name: InternalNamePath; errors: string[] }[]) => {\r\n    //存在错误将错误整理返回\r\n      const errorList = results.filter(result => result && result.errors.length);\r\n      return Promise.reject({\r\n        values: this.getFieldsValue(namePathList),\r\n        errorFields: errorList,\r\n        outOfDate: this.lastValidatePromise !== summaryPromise,\r\n      });\r\n    });\r\n\r\n  // Do not throw in console\r\n  returnPromise.catch<ValidateErrorEntity>(e => e);\r\n\r\n  return returnPromise as Promise<Store>;\r\n  };\r\n```\r\n这里的代码比较长，我们来整理一下关键的地方：如果传入了nameList那么会对nameList对应的Field进行校验，否则就会全部校验，当然他们需要传入了rules，而这里的校验方法其实是调用的Field组件的validateRules方法，这个函数我们后续会分析，然后我们会把validateRules返回的promise收集到promiseList中，通过allPromiseFinish函数，我们就可以拿到校验结果的数组了，接下来主要就是2件事，一是通知对应的Field进行更新，二是根据校验结果返回Promise作为 onFinishFailed和onFinish的触发依据，这里的逻辑也比较简单。所以下面我们就来看看Field组件中的validateRules方法\r\n\r\n```js\r\npublic validateRules = (options?: InternalValidateOptions): Promise<RuleError[]> => {\r\n\r\n  const namePath = this.getNamePath();\r\n  const currentValue = this.getValue();\r\n\r\n  const { triggerName, validateOnly = false } = options || {};\r\n  \r\n  const rootPromise = Promise.resolve().then(async (): Promise<any[]> => {\r\n    if (!this.mounted) {\r\n      return [];\r\n    }\r\n\r\n    const { validateFirst = false, messageVariables, validateDebounce } = this.props;\r\n\r\n    // 对rule的一些过滤，这里主要是排除空校验和触发时机不满足的\r\n    let filteredRules = this.getRules();\r\n    if (triggerName) {\r\n      filteredRules = filteredRules\r\n        .filter(rule => rule)\r\n        .filter((rule: RuleObject) => {\r\n          const { validateTrigger } = rule;\r\n          if (!validateTrigger) {\r\n            return true;\r\n          }\r\n          const triggerList = toArray(validateTrigger);\r\n          return triggerList.includes(triggerName);\r\n        });\r\n    }\r\n    \r\n     ......\r\n     \r\n    //其实这个promise就是包含了当前检验结果的promise\r\n    const promise = validateRules(\r\n      namePath,\r\n      currentValue,\r\n      filteredRules,\r\n      options,\r\n      validateFirst,\r\n      messageVariables,\r\n    );\r\n\r\n    promise\r\n      .catch(e => e)\r\n      .then((ruleErrors: RuleError[] = EMPTY_ERRORS) => {\r\n        if (this.validatePromise === rootPromise) {\r\n          this.validatePromise = null;\r\n\r\n          //根据option处理数据跟前面相似\r\n          const nextErrors: string[] = [];\r\n          const nextWarnings: string[] = [];\r\n          ruleErrors.forEach?.(({ rule: { warningOnly }, errors = EMPTY_ERRORS }) => {\r\n            if (warningOnly) {\r\n              nextWarnings.push(...errors);\r\n            } else {\r\n              nextErrors.push(...errors);\r\n            }\r\n          });\r\n           把结果存储在当前Field上\r\n          this.errors = nextErrors;\r\n          this.warnings = nextWarnings;\r\n          this.triggerMetaEvent();\r\n          this.reRender();\r\n        }\r\n      });\r\n\r\n    return promise;\r\n  });\r\n\r\n  if (validateOnly) {\r\n    return rootPromise;\r\n  }\r\n  //一些数据的更新\r\n  this.validatePromise = rootPromise;\r\n  this.dirty = true;\r\n  this.errors = EMPTY_ERRORS;\r\n  this.warnings = EMPTY_ERRORS;\r\n  this.triggerMetaEvent();\r\n\r\n  // Force trigger re-render since we need sync renderProps with new meta\r\n  this.reRender();\r\n  //可以看到正常流程下其实就是返回的validateRules(...args)的promise结果\r\n  return rootPromise;\r\n  };\r\n```\r\n所以这里的大部分代码还是在进行流程的串联和Field内部状态的一些处理，校验相关的还是也并非在这里实现，其实rc-field-form的表单校验依赖了rc-component/async-validator，然后对其进行了一些封装，这里也不做过多介绍了。\r\n# 三 一些其他功能\r\n上面聊完了form的核心功能，下面我们再来看一看一些比较好用的特性.\r\n首先是list组件，这里我放一个[antd的例子](https://ant.design/components/form-cn#components-form-demo-dynamic-form-item)，不熟悉的可以去了解一下效果。\r\n### List\r\n\r\n```js\r\n <List name='xxx'>\r\n {(fields, { add, remove }, { errors }) => (\r\n          <>\r\n            {fields.map((field, index) => (\r\n                <Field\r\n                  {...field}\r\n                >\r\n                  <Input placeholder=\"passenger name\"/>\r\n                </Field>\r\n            ))}\r\n          </>\r\n        )}\r\n      </List>\r\n```\r\n大概的使用方法如上，我们需要给List组件传入一个函数，然后在这个函数里通过组件给我们的fields参数进行遍历渲染出每个Field，同时他也给我们提供了一些方法对数据进行操控，下面我们一起来看看如何实现。先贴出这个组件的代码，然后我们来慢慢分析。\r\n\r\n```js\r\nfunction List<Values = any>({\r\n  name,\r\n  initialValue,\r\n  children,\r\n  rules,\r\n  validateTrigger,\r\n  isListField,\r\n}: ListProps<Values>) {\r\n//存放了formInstance和validateTrigger\r\n  const context = React.useContext(FieldContext);\r\n  //现在这里还没有东西\r\n  const wrapperListContext = React.useContext(ListContext);\r\n  const keyRef = React.useRef({\r\n    keys: [],\r\n    id: 0,\r\n  });\r\n  const keyManager = keyRef.current;\r\n  //获取当前的Fieldname\r\n  const prefixName: InternalNamePath = React.useMemo(() => {\r\n    const parentPrefixName = getNamePath(context.prefixName) || [];\r\n    return [...parentPrefixName, ...getNamePath(name)];\r\n  }, [context.prefixName, name]);\r\n  //创建context传递firminstance和name\r\n  const fieldContext = React.useMemo(() => ({ ...context, prefixName }), [context, prefixName]);\r\n\r\n  // 创建list的context\r\n  const listContext = React.useMemo<ListContextProps>(\r\n    () => ({\r\n      getKey: (namePath: InternalNamePath) => {\r\n        const len = prefixName.length;\r\n        const pathName = namePath[len];\r\n        return [keyManager.keys[pathName], namePath.slice(len + 1)];\r\n      },\r\n    }),\r\n    [prefixName],\r\n  );\r\n  // list组件的children只能传入函数\r\n  if (typeof children !== 'function') {\r\n    warning(false, 'Form.List only accepts function as children.');\r\n    return null;\r\n  }\r\n //辅助更新\r\n  const shouldUpdate = (prevValue: StoreValue, nextValue: StoreValue, { source }) => {\r\n    if (source === 'internal') {\r\n      return false;\r\n    }\r\n    return prevValue !== nextValue;\r\n  };\r\n \r\n  return (\r\n    <ListContext.Provider value={listContext}>\r\n      <FieldContext.Provider value={fieldContext}>\r\n        <Field\r\n          name={[]}\r\n          shouldUpdate={shouldUpdate}\r\n          rules={rules}\r\n          validateTrigger={validateTrigger}\r\n          initialValue={initialValue}\r\n          isList\r\n          isListField={isListField ?? !!wrapperListContext}\r\n        >\r\n         .........\r\n         \r\n        </Field>\r\n      </FieldContext.Provider>\r\n    </ListContext.Provider>\r\n  );\r\n}\r\n```\r\n看到这里其实我们能够发现，list组件其实还是根据Field组件进行的封装，现在我们再来看看Field组件里都有什么东西\r\n\r\n```js\r\n{({ value = [], onChange }, meta) => {\r\n  const { getFieldValue } = context;\r\n  //获取当前Filed维护的值\r\n  const getNewValue = () => {\r\n      const values = getFieldValue(prefixName || []) as StoreValue[];\r\n      return values || [];\r\n };\r\n    const operations: ListOperations = {\r\n      add: (defaultValue, index?: number) => {\r\n         // Mapping keys\r\n        const newValue = getNewValue();\r\n        console.log(newValue,defaultValue)\r\n         if (index >= 0 && index <= newValue.length) {\r\n          keyManager.keys = [\r\n             ...keyManager.keys.slice(0, index),\r\n            keyManager.id,\r\n             ...keyManager.keys.slice(index),\r\n          ];\r\n          onChange([...newValue.slice(0, index), defaultValue, ...newValue.slice(index)]);\r\n         } else {\r\n          if (\r\n             process.env.NODE_ENV !== 'production' &&\r\n            (index < 0 || index > newValue.length)\r\n           ) {\r\n             warning(\r\n                false,\r\n               'The second parameter of the add function should be a valid positivenumber.',\r\n             );\r\n           }\r\n           keyManager.keys = [...keyManager.keys, keyManager.id];\r\n           console.log(keyManager)\r\n           onChange([...newValue, defaultValue]);\r\n        }\r\n         keyManager.id += 1;\r\n      }，\r\n\r\n     let listValue = value || [];\r\n     if (!Array.isArray(listValue)) {\r\n      listValue = [];\r\n\r\n       if (process.env.NODE_ENV !== 'production') {\r\n         warning(\r\n           false,\r\n           `Current value of '${prefixName.join(' > ')}' is not an array type.`,\r\n         );\r\n       }\r\n     }\r\n\r\n    return children(\r\n      (listValue as StoreValue[]).map((__, index): ListField => {\r\n        let key = keyManager.keys[index];\r\n        if (key === undefined) {\r\n         keyManager.keys[index] = keyManager.id;\r\n            key = keyManager.keys[index];\r\n            keyManager.id += 1;\r\n          }\r\n\r\n         return {\r\n           name: index,\r\n           key,\r\n           isListField: true,\r\n         };\r\n       }),\r\n       operations,\r\n       meta,\r\n     );\r\n    }}\r\n```\r\n 首先我们注意到，Field组件里我们传入的也是一个函数，这里需要先带大家复习一下，在Field组件中，如果我们传入的child是一个函数，那么会传入getControlled(), meta,fieldContext这3个参数(相关函数getOnlyChild )，并将函数的返回值作为最终的child,meta其实就是Field的一些状态，接下来来看看operations\r\n\r\n```js\r\n   const operations: ListOperations = {\r\n      add: (defaultValue, index?: number) => {\r\n         // 其实这里获取的就是当前的值\r\n        const newValue = getNewValue();\r\n        如果传入了index并且index没有超出当前index就插入\r\n         if (index >= 0 && index <= newValue.length) {\r\n          keyManager.keys = [\r\n             ...keyManager.keys.slice(0, index),\r\n            keyManager.id,\r\n             ...keyManager.keys.slice(index),\r\n          ];\r\n          //一个onChange方法，传入了新值\r\n          onChange([...newValue.slice(0, index), defaultValue, ...newValue.slice(index)]);\r\n         } else {\r\n          if (\r\n             process.env.NODE_ENV !== 'production' &&\r\n            (index < 0 || index > newValue.length)\r\n           ) {\r\n           //一些错误处理\r\n             warning(\r\n                false,\r\n               'The second parameter of the add function should be a valid positivenumber.',\r\n             );\r\n           }\r\n           //否者默认将值更新到最后\r\n           keyManager.keys = [...keyManager.keys, keyManager.id];\r\n           onChange([...newValue, defaultValue]);\r\n        }\r\n         keyManager.id += 1;\r\n      }，\r\n```\r\n其实这一部分就是维护了一个对象，提供了之前add等一些修改数据的方法，其他方法这里省略了。\r\n\r\n```js\r\n let listValue = value || [];\r\n if (!Array.isArray(listValue)) {\r\n   listValue = [];\r\n\r\n   if (process.env.NODE_ENV !== 'production') {\r\n      warning(false,`Current value of '${prefixName.join(' > ')}' is not an array type.`);\r\n    }\r\n }\r\n```\r\n这里也很简单，对listvalue进行了一些判断，接下来是最后的一部分\r\n\r\n```js\r\n     return children(\r\n       (listValue as StoreValue[]).map((__, index): ListField => {\r\n         let key = keyManager.keys[index];\r\n         if (key === undefined) {\r\n           keyManager.keys[index] = keyManager.id;\r\n           key = keyManager.keys[index];\r\n           keyManager.id += 1;\r\n         }\r\n\r\n         return {\r\n           name: index,\r\n           key,\r\n           isListField: true,\r\n         };\r\n       }),\r\n       operations,\r\n       meta,\r\n     );\r\n```\r\n这里的children是什么呢，其实这里的children就是我们在List组件里传入的函数，这样的话就很明显了List组件帮其实就是帮我们进行了数据管理，并将操作数据的方法暴露给我们，我们再来看看最开始我们是如何使用List组件的\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d444717d4fbd4ef093f83dd6caf141e9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1018&h=362&s=28328&e=png&b=f8f8f8)\r\n这里传递的filed属性其实就把这样的属性传递给了Field。\r\n\r\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a829367ec294c9b95363a2581ac74f6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=340&h=87&s=18232&e=png&b=202021)  \r\n接着我们再来看看List组件为什么能够做到对子数据的统一管理呢。  \r\n 举个简单的例子，比如我们维护了一个users的Field数组，那么他的数据结构大概是 *users:['xiaomin','xiaozhang']*,当我们通过list组件暴露出来的方法对数据进行修改时因为list组件是基于Field的封装，所以这些修改会触发onStoreChange让list组件rerender，而其中的子Field自然也会重新渲染，那么子Field是如何获取正确的值呢，看上面那张图，我们给子组件传递了一个key，在getControlled的时候，Field会调用getValue方法获取值，其实这个getValue函数就类似与lodash中的get方法，而如果一个Field是listField的话，那么当我们获取namePath时其实一种 [parentName,key] 的形式\r\n\r\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98f7336c717643948c80631320734068~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=143&h=42&s=1501&e=png&b=fffefe)\r\n所以我们就可以根据这个获取新值达到更新的效果，这里还有一点，某个子Field的更新其实是不会影响到List组件的。\r\n### dependence\r\n最后我们再来聊一聊另一个功能，dependence.这里还是给出一个[antd的例子](https://ant.design/components/form-cn#components-form-demo-form-dependencies)，简单的说，就是我们可以给某个Flied配置dependence字段，当dependence数组中包含的Field触发了更新，这个Field也会同步触发更新。 下面是rc-field-form官方demo，大家可以自己试一下。当name为1时可以看到password渲染，然后password如果不为空则password2渲染 ，**后来在写文章的时候感觉这个例子是有问题的，我们一会再分析**\r\n\r\n```js\r\nimport Form, { Field } from 'rc-field-form';\r\nimport React from 'react';\r\nimport Input from './components/Input';\r\n\r\ntype FormData = {\r\n  name?: string;\r\n  password?: string;\r\n  password2?: string;\r\n};\r\n\r\nexport default () => {\r\n  const [form] = Form.useForm();\r\n\r\n  return (\r\n    <Form\r\n      form={form}\r\n      preserve={false}\r\n      onFieldsChange={fields => {\r\n        console.error('fields:', fields);\r\n      }}\r\n    >\r\n      <Field<FormData> name=\"name\">\r\n        <Input placeholder=\"Username\" />\r\n      </Field>\r\n\r\n      <Field<FormData> dependencies={['name']}>\r\n        {() => {\r\n          return form.getFieldValue('name') === '1' ? (\r\n            <Field name=\"password\">\r\n              <Input placeholder=\"Password\" />\r\n            </Field>\r\n          ) : null;\r\n        }}\r\n      </Field>\r\n\r\n      <Field dependencies={['password']}>\r\n        {() => {\r\n          const password = form.getFieldValue('password');\r\n          console.log('>>>', password);\r\n          return password ? (\r\n            <Field<FormData> name={['password2']}>\r\n              <Input placeholder=\"Password 2\" />\r\n            </Field>\r\n          ) : null;\r\n        }}\r\n      </Field>\r\n\r\n      <button onClick={()=} type=\"submit\">Submit</button>\r\n    </Form>\r\n  );\r\n};\r\n```\r\n这里我们直接来讲他是如何实现的,我看了一下源码然后写demo测试后发现在rc-field-form里如果我们通过如setFieldValue这样的api是无法触发dependence更新的，这里我们就只聊通过onChange等行为触发的更新。\r\n\r\n```js\r\n  private updateValue = (name: NamePath, value: StoreValue) => {\r\n  \r\n   ......\r\n\r\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\r\n   ......\r\n  };\r\n```\r\n可以看到具体的逻辑是由**updateValue**开始的，我们先来看看**triggerDependenciesUpdate**干了啥\r\n\r\n```js\r\n  private triggerDependenciesUpdate = (prevStore: Store, namePath: InternalNamePath) => {\r\n  //这个函数等会讲，其实就是拿到依赖于当前字段的Field\r\n    const childrenFields = this.getDependencyChildrenFields(namePath);\r\n    //对依赖于当前字段的Field进行校验\r\n    if (childrenFields.length) {\r\n      this.validateFields(childrenFields);\r\n    }\r\n    //通知更新\r\n    this.notifyObservers(prevStore, childrenFields, {\r\n      type: 'dependenciesUpdate',\r\n      relatedFields: [namePath, ...childrenFields],\r\n    });\r\n\r\n    return childrenFields;\r\n  };\r\n\r\n```\r\n接下来我们看看**getDependencyChildrenFields**这个方法，\r\n\r\n```js\r\n  private getDependencyChildrenFields = (rootNamePath: InternalNamePath): InternalNamePath[] => {   \r\n    const children: Set<FieldEntity> = new Set();\r\n    //返回值，这个是被打平的denpendence\r\n    const childrenFields: InternalNamePath[] = [];\r\n    //用于存储依赖的map\r\n    const dependencies2fields: NameMap<Set<FieldEntity>> = new NameMap();\r\n    \r\n    ........\r\n    \r\n    return childrenFields;\r\n  };\r\n```\r\n接下来我们来看看具体的处理，首先是构建依赖map\r\n\r\n```js\r\n    this.getFieldEntities().forEach(field => {\r\n      console.log(field.props.dependencies)\r\n      const { dependencies } = field.props;\r\n      (dependencies || []).forEach(dependency => {\r\n        const dependencyNamePath = getNamePath(dependency);\r\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\r\n          fields.add(field);\r\n          return fields;\r\n        });\r\n      });\r\n    });\r\n```\r\n举个例子，如果C和D依赖B，B依赖A，这样就会创建出这样的map来，我们为什么需要这样的操作呢，其实我们可以想一下，在这个例子中，虽然C，D的dependence是B，但是B同时也依赖于A，那么如果A触发了更新，C和D也应该更新，所以**getDependencyChildrenFields**就是为了解决这种循环依赖，现在我们已经有了dependenceMap，接下来就需要通过这个map获取所有的依赖\r\n\r\n```js\r\n{\r\n    A: [FieldB],\r\n    B: [FieldC，FieldD]\r\n}\r\n\r\n```\r\n\r\n```js\r\n    const fillChildren = (namePath: InternalNamePath) => {\r\n      //获取直接依赖于它的Field\r\n      const fields = dependencies2fields.get(namePath) || new Set();\r\n      //查看是否有Field间接依赖\r\n      fields.forEach(field => {\r\n      //只判断未判断过的\r\n        if (!children.has(field)) {\r\n          children.add(field);\r\n\r\n          const fieldNamePath = field.getNamePath();\r\n          if (fieldNamePath.length) {\r\n            childrenFields.push(fieldNamePath);\r\n            fillChildren(fieldNamePath);\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    fillChildren(rootNamePath);\r\n```\r\n这样我们就可以拿到所有依赖的Field了，我们继续回到更新的流程。\r\n\r\n```js\r\n    this.notifyObservers(prevStore, childrenFields, {\r\n      type: 'dependenciesUpdate',\r\n      relatedFields: [namePath, ...childrenFields],\r\n    });\r\n```\r\n这里已经很熟悉了，通过notifyObserver调用所有Field的onStoreChange，我们直接看在onStoreChange里进行了哪些操作\r\n\r\n```js\r\n\r\n      case 'dependenciesUpdate': {\r\n        //获取当前Field的dependence\r\n        const dependencyList = dependencies.map(getNamePath);\r\n        //如果某个依赖被包含在relatedFields中就触发更新\r\n        if (dependencyList.some(dependency => containsNamePath(info.relatedFields, dependency))) {\r\n          this.reRender();\r\n          return;\r\n        }\r\n        break;\r\n      }\r\n```\r\n其实这里也比较简单，所以dependence的流程我们也分析完了。  \r\n最后就是说说刚才我提到了官方的demo有问题，下面就来谈谈为什么有问题。还是先放一下代码\r\n\r\n```js\r\n```js\r\nimport Form, { Field } from 'rc-field-form';\r\nimport React from 'react';\r\nimport Input from './components/Input';\r\n\r\ntype FormData = {\r\n  name?: string;\r\n  password?: string;\r\n  password2?: string;\r\n};\r\n\r\nexport default () => {\r\n  const [form] = Form.useForm();\r\n\r\n  return (\r\n    <Form\r\n      form={form}\r\n      preserve={false}\r\n      onFieldsChange={fields => {\r\n        console.error('fields:', fields);\r\n      }}\r\n    >\r\n      <Field<FormData> name=\"name\">\r\n        <Input placeholder=\"Username\" />\r\n      </Field>\r\n\r\n      <Field<FormData> dependencies={['name']}>\r\n        {() => {\r\n          return form.getFieldValue('name') === '1' ? (\r\n            <Field name=\"password\">\r\n              <Input placeholder=\"Password\" />\r\n            </Field>\r\n          ) : null;\r\n        }}\r\n      </Field>\r\n\r\n      <Field dependencies={['password']}>\r\n        {() => {\r\n          const password = form.getFieldValue('password');\r\n          console.log('>>>', password);\r\n          return password ? (\r\n            <Field<FormData> name={['password2']}>\r\n              <Input placeholder=\"Password 2\" />\r\n            </Field>\r\n          ) : null;\r\n        }}\r\n      </Field>\r\n\r\n      <button onClick={()=} type=\"submit\">Submit</button>\r\n    </Form>\r\n  );\r\n};\r\n```\r\n首先，我们可以看到在官方demo中每个配置了dependence的Filed字段其实是没有配置name的，但是当我们构建childrenFields时是需要获取Field的name的，这就导致了获取childrenFields其实是获取了一个空数组，这样看来，如果当前name=1,password存在value，然后我们改变name的值，password和password1都不会隐藏，但是我们可以发现这个demo运行起来其实是没有问题的，这是为什么呢。  \r\n关键在这里：\r\n\r\n```js\r\n    this.notifyObservers(prevStore, childrenFields, {\r\n      type: 'dependenciesUpdate',\r\n      relatedFields: [namePath, ...childrenFields],\r\n    });\r\n```\r\n我们在触发dependence更新的时候在relatedFields中还把触发更新的Field name传递了过去，这里也就是'name',所以当我们触发所有组件的onStoreChange，password是能够更新的，那password1又是如何正确更新的呢？\r\n\r\n![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81e16c73048f4503b22dc41a989bde02~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=828&h=262&s=141570&e=png&b=222023)\r\n还记得这个方法吗，password这个Field在卸载的时候会执行这个方法，这个方法其实就是registerField的返回函数，而这个返回函数里又调用了`this.triggerDependenciesUpdate(prevStore, namePath);`，后面的流程就跟上面相似了。  \r\n# 完结撒花\r\n写了这么多终于把rc-field-form的一些主要流程讲完了🧐，第一次写文章写的真挺烂的，最后还是大家推荐一些关于rc-field-form的文章： \r\n- [一次手写Antd Form的经历，让我受益匪浅 - 掘金 (juejin.cn)](https://juejin.cn/post/7038099720400535582)\r\n- [手写一个 Antd4 Form 吧（上篇）：源码分析 - 掘金 (juejin.cn)](https://juejin.cn/post/7116390485710602254)\r\n- [🍓中台表单技术选型实践(表单实践) - 掘金 (juejin.cn)](https://juejin.cn/post/7316723621292638246)",
      "count": "34k",
      "readingTime": "2:51",
      "imageUrls": [],
      "createdAt": null,
      "updatedAt": null,
      "modified": false
    }
  ]
}