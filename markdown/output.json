{
  "postDataMap": {
    "yyblog": {
      "authors": [
        "yy"
      ],
      "title": "yyblog",
      "tag": "技术/react",
      "path": "yyblog",
      "rawFilePath": "./yyblog.md",
      "coverImage": "https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b76076eab124179816d68b846280cdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWVnYXRyb25LaW5n:q75.awebp?rk3s=f64ab15b&x-expires=1731736114&x-signature=3ggdE9od5WvMZaVJ7VFlQtt48rA%3D",
      "text": "原本，我利用 Hexo 搭建了一个个人博客，刚开始还挺新鲜的，但慢慢就觉得样式单调，而且我想加入评论以及流量监控很麻烦。所以想着要不自己手写一个，更好控制也能自定义样式。于是 yyblog 就孕育而生\r\n\r\n# 结构一点测试eeee\r\n\r\n整个博客，不仅仅由 yyblog 组成，还有 ybg-cli 脚手架，用于自动创建删除文章以及编译文章。\r\n![Minion](https://octodex.github.com/images/minion.png)\r\n\r\n```javascript\r\nconsole.log('Hello, world!');\r\n```\r\n\r\n- **yyblog**\r\n\r\n  - Nextjs\r\n  - typescript\r\n  - tailwind\r\n  - react-syntax-highlighter\r\n\r\n- **ybg-cli**\r\n  - cac\r\n  - gray-matter\r\n  - he\r\n\r\n## yyblog\r\n\r\n采用`Nextjs`+`Typescript`+`Tailwindw`为主要技术。\r\n\r\n<details>\r\n  <summary>点击展开更多信息</summary>\r\n  这是详细的内容，可以在点击时展开。\r\n</details>\r\n\r\n效仿 Hexo 采用纯前端，文章编写删除编译都在本地运行，对前端工程师更友好。\r\nNextjs 同时也支持全栈开发。简单的 sql 语句也能够对文章进行增删改查。\r\n\r\nNext 提供的文件路由同时也可以帮我们自定义一些特殊页面，常见的 layout 页面，404 页面以及错误页面等等。\r\n\r\n> 避免中文命名文件！！\r\n\r\n除了文件路由以外，Next 也提供了很多组件以及优化，比如 `font`，`<Image>`标签还有`<Script>`标签。\r\n这里说一下`<Script>`，博客网站上我放了一些动画(来源于 codepen),而这些动画`script`脚本，放入 `tsx(jsx)` 中只能通过`dangerouslySetInnerHTML`这个极具风险的 attribute\r\n但正好 Nextjs 提供了一个`<Script>`，能够让我们使用脚本组件。\r\n\r\n## ybg-cli\r\n\r\n采用纯前端的重点就在于文章的生成删除以及编译，麻烦就麻烦在编译成 TSX 代码插入到 yyblog 中形成页面。\r\n\r\n光看文字不如上点代码：\r\n\r\n```typescript\r\nexport async function compileFile(): Promise<mdFile[]> {\r\n  let compiledFiles: mdFile[] = [];\r\n  const fileList = fs.readdirSync(_postFolder);\r\n  for (const file of fileList) {\r\n    const filePath = path.join(_postFolder, file);\r\n    const fileContent = fs.readFileSync(filePath, 'utf-8');\r\n    const parsedFile = matter(fileContent);\r\n    const newMatter = {\r\n      ...parsedFile,\r\n      data: { ...parsedFile.data, date: UTCToString(parsedFile.data.date) },\r\n    };\r\n    const picPath = makeImportPic(await marked(parsedFile.content));\r\n    const htmlText = HtmlToNext(await marked(parsedFile.content));\r\n    compiledFiles.push(\r\n      picPath\r\n        ? {\r\n            mdMatter: newMatter,\r\n            mdHtml: htmlText,\r\n            other: {\r\n              picPath: picPath,\r\n            },\r\n          }\r\n        : { mdMatter: newMatter, mdHtml: htmlText },\r\n    );\r\n  }\r\n  return compiledFiles;\r\n}\r\n```\r\n\r\n读取文件并且用 gray-matter 解析 md 文件生成对应的内容。\r\n`mdMatter`是文章头部`yaml`格式内容的解析。\r\n`mdHtml`是文章主题部分的解析。\r\n`other`是解析成 Html 后需要插入到最后 TSX 内容的东西。\r\n\r\n重点在于`HtmlToNext`函数:\r\n\r\n```tsx\r\nimport he from 'he';\r\nfunction ImageRepimg(html: string) {\r\n  const processedHtml = html.replace(\r\n    /<img\\s+src=\"(.*?)\"\\s+alt=\"(.*?)\".*?\\/>/g,\r\n    function (match, src, alt) {\r\n      const modifiedSrc = src.split('/');\r\n      const newSrc = modifiedSrc[modifiedSrc.length - 1]; //修改后的SRC\r\n\r\n      const modifiedAlt = alt; // 修改后的alt\r\n\r\n      return `<Image src={${newSrc.slice(0, newSrc.lastIndexOf('.'))}} alt=\"${modifiedAlt}\" \r\n      sizes=\"100vw\"\r\n      style={{\r\n        width: '100%',\r\n        height: 'auto',\r\n      }} />`;\r\n    },\r\n  );\r\n  return processedHtml;\r\n}\r\nfunction replaceClassName(html: string) {\r\n  const processedHtml = html.replace(/class=/g, 'className=');\r\n  return processedHtml;\r\n}\r\nfunction highLightHtml(html: string) {\r\n  // 在代码块内的特殊字符前加上 \\\r\n  const replacedString1 = html.replace(\r\n    /<pre><code className=\"language-(\\w+)\">([\\s\\S]*?)<\\/code><\\/pre>/g,\r\n    (_, language, codeContent) => {\r\n      //转义符删除\r\n      const decodeCode = he.decode(codeContent);\r\n      const codeWithBackslash = decodeCode.replace(/([^\\w\\s\"'])/g, '\\\\$1');\r\n      return `<SyntaxHighlighter language=\"${language}\" style={oneLight} showLineNumbers>{ \\`${codeWithBackslash}\\` }</SyntaxHighlighter>`;\r\n    },\r\n  );\r\n\r\n  return replacedString1;\r\n}\r\nexport function HtmlToNext(html: string) {\r\n  //替换img标签\r\n  const step1Html = ImageRepimg(html);\r\n  //替换class为className\r\n  const step2Html = replaceClassName(step1Html);\r\n  //高亮代码\r\n  const step3Html = highLightHtml(step2Html);\r\n  //闭合分割线\r\n  const step4Html = step3Html.replace(/<hr>/g, '<hr />');\r\n  return step4Html;\r\n}\r\n```\r\n\r\n通过对解析后 html 的修改，主要是用正则，实现 html 向 TSX(Next)的转化。\r\n\r\n# 3月4号更新：\r\n\r\n更新了英文版，主要采用的是Next的中间件-`middleware.js`以及`react-i18next`和`i18next`,这两个库i18n转化库。\r\n\r\n配置的教程在[这里](https://locize.com/blog/next-app-dir-i18n/)\r\n\r\n```javascript\r\nimport { NextResponse } from 'next/server';\r\nimport acceptLanguage from 'accept-language';\r\nimport { fallbackLng, languages, cookieName } from '@/app/i18n/setting';\r\n\r\nacceptLanguage.languages(languages);\r\n\r\nexport const config = {\r\n  // matcher: '/:lng*'\r\n  matcher: ['/((?!api|_next/static|_next/image|imgs|favicon.ico|sw.js).*)'],\r\n};\r\nexport function middleware(req) {\r\n  let lng;\r\n  if (req.cookies.has(cookieName)) lng = acceptLanguage.get(req.cookies.get(cookieName).value);\r\n  if (!lng) lng = acceptLanguage.get(req.headers.get('Accept-Language'));\r\n  if (!lng) lng = fallbackLng;\r\n\r\n  // Redirect if lng in path is not supported\r\n\r\n  if (\r\n    !languages.some((loc) => req.nextUrl.pathname.startsWith(`/${loc}`)) &&\r\n    !req.nextUrl.pathname.startsWith('/_next')\r\n  ) {\r\n    return NextResponse.redirect(new URL(`/${lng}${req.nextUrl.pathname}`, req.url));\r\n  }\r\n  if (req.headers.has('referer')) {\r\n    const refererUrl = new URL(req.headers.get('referer'));\r\n    const lngInReferer = languages.find((l) => refererUrl.pathname.startsWith(`/${l}`));\r\n    const response = NextResponse.next();\r\n    if (lngInReferer) response.cookies.set(cookieName, lngInReferer);\r\n    return response;\r\n  }\r\n\r\n  return NextResponse.next();\r\n}\r\n```\r\n\r\n这一段是中间件主要的代码，作用是用户使用不支持语言时自动跳转到默认语言，记住用户每次结束后使用的语言。\r\n\r\n**注意:**\r\n\r\n```js\r\nexport const config = {\r\n  // matcher: '/:lng*'\r\n  matcher: ['/((?!api|_next/static|_next/image|imgs|favicon.ico|sw.js).*)'],\r\n};\r\n```\r\n\r\n`matcher`匹配器用于使得中间件在特定的路径上执行。\r\n这个字符串是负向预测先行，用于匹配不包含以上内容的字符串片段，你需要稍微修改正则以匹配你的文件目录。\r\n\r\n# 3月24号更新：\r\n\r\n**一键部署**\r\n\r\n选择一个静态页面管理网站，比如githubpage或者vercrel，绑定自己的博客仓库。\r\n在根目录下设置`_blog.json`,配置文件：\r\n\r\n```json\r\n{\r\n  \"deployCon\": {\r\n    \"commitMessage\": \"docs: new essay\", //每次commit的message\r\n    \"remote_store_url\": \"https://github.com/YYGod0120/yyblog.git\", //远程仓库url\r\n    \"remote_store_name\": \"origin\", //别名\r\n    \"branch\": \"main\" //想要提交的分支\r\n  }\r\n}\r\n```\r\n\r\n然后使用`ybg init`进行初始化。\r\n最后每次写完文章执行`pnpm d`进行部署。\r\n\r\n# 附件\r\n\r\n> 一些使用到的库或者代码：\r\n\r\n- [gray-matter](https://github.com/jonschlinkert/gray-matter)：解析静态网页元数据\r\n- [marked](https://github.com/markedjs/marked)：转化`md`文件为 HTML\r\n- [rimraf](https://github.com/isaacs/rimraf)：快捷删除文件夹及其内容\r\n- [tsup](https://github.com/egoist/tsup)：快速构建 TypeScript 项目的工具\r\n- [picocolors](https://github.com/alexeyraspopov/picocolors)：命令行颜色\r\n- [cac](https://github.com/cacjs/cac)：构建命令行工具的 JavaScript/TypeScript 框架\r\n- [codepen](https://codepen.io/)： 动画及特别的 404 页面都来源于此\r\n- [react-i18next](https://github.com/i18next/react-i18next) i18n for react\r\n",
      "count": "5.3k",
      "readingTime": "26 ",
      "createdAt": "2024-11-08T15:07:01.000Z",
      "updatedAt": "2024-11-09T13:41:44.000Z",
      "modified": true
    },
    "react19": {
      "authors": [
        "yy"
      ],
      "title": "react19",
      "tag": "随笔/生活",
      "path": "react19",
      "rawFilePath": "./react19.md",
      "summary": "这篇文章记录了react19相关的一些内容",
      "coverImage": "https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b76076eab124179816d68b846280cdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWVnYXRyb25LaW5n:q75.awebp?rk3s=f64ab15b&x-expires=1731736114&x-signature=3ggdE9od5WvMZaVJ7VFlQtt48rA%3D",
      "text": "# React19qqqq31231\r\n\r\n4月25日，React官方宣布React19在NPM上推出，可以先行下载使用。\r\n正好此博客也是NextJS搭建的，尝试一下React19带来哪些变化。\r\n\r\n## 准备测试修改\r\n\r\n官方的建议是先安装稳定版本的React18.3,以在更新到19前发现一些潜藏的问题。\r\n检查无误后，就可以安装React-19（还处于BETA）使用新API。\r\n[React-v19的升级指南](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#typescript-changes)\r\n\r\n## 变化\r\n\r\nReact在沉寂一长段时间后，听取社区的意见，改掉许多开发痛点以及优化框架。重磅推出了React19\r\n\r\n**重大的改变有以下几点：**\r\n\r\n- React-Compiler：帮助开发人员自动优化页面，减少甚至抛弃useMemo和useCallback。\r\n- Actions：新的`<form>`标签以及配套的Hooks表单操作。\r\n- New Hooks：新的增强操作钩子如`use()`等等。\r\n- Document Metadata：现在可以直接在单个组件里编写Meta数据。\r\n- Web components：React 代码现在将使我们能够合并 Web 组件。\r\n\r\n### React-Compiler\r\n\r\nReactCompiler可以说是19里最让人激动的东西，它是一个新的编译器，用于帮程序员优化React代码。\r\n比如说先前的useMemo，useCallback等等这一系列的优化钩子，不说使用起来麻烦，使用不当甚至还会造成负优化。于是React推出了Compiler直接自动处理代码，避免了负优化的现象。\r\n\r\n简单来说，Compiler做到的事情就是将组件中每个元素，每一个函数都进行缓存，只有当发生变化的时候才会重新缓存，不然就接着使用。\r\n本文主要是说使用而非原理，具体可以查看这篇文章[我已彻底拿捏 React Compiler](https://mp.weixin.qq.com/s/7XFn56O3ia5vHPqSaeo6GA)\r\n\r\n对于React-Compiler的启用，我们首先要对我们的项目做一个检测。\r\n\r\n```shell\r\nnpx react-compiler-healthcheck\r\n```\r\n\r\n> 该脚本主要用于检测\r\n> 1、项目中有多少组件可以成功优化：越多越好\r\n> 2、是否使用严格模式，使用了优化成功率更高\r\n> 3、是否使用了与 Compiler 不兼容的三方库\r\n\r\n这个框架的检测效果如下：\r\n<img src=\"/imgs/React19-BETA/test.png\" alt=\"react-server-components\"  />\r\n对于不同的框架使用Compiler的方法不同，Next启用Compiler需要先下载Next-canary版以及babel-plugin-react-compiler\r\n\r\n```shell\r\nnpm install next@canary babel-plugin-react-compiler\r\n```\r\n\r\n然后在`next.config.js`:\r\n\r\n```js\r\n// next.config.js\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    reactCompiler: true,\r\n  },\r\n};\r\n\r\nmodule.exports = nextConfig;\r\n```\r\n\r\n便可以启动compiler对项目进行优化。\r\n成功优化后，可以在React-dev-tool就会看到Memo星星。\r\n<img src=\"/imgs/React19-BETA/compiler.png\" alt=\"react-server-components\"/>\r\n\r\n> 值得一说的是Compiler还在测试中，存在不少问题，比如与i18n的客户端组件存在一些冲突等，所以有待观望\r\n\r\n### New Hooks\r\n\r\nReact19更新许多新的Hooks，包括`use()`,`useOptimistic()`,`useFormStatus()`,绝大多是都是为了Action也就是`<form>`标签所适配的。\r\n\r\n因为没用到表单，所以我只先使用`use()`。\r\n\r\nuse用于获取资源的值，比如说Promise或者Context。和其他钩子不同，它可以在if语句中使用。\r\n\r\n他的具体原理如下(取自官方文档)：\r\n\r\n> 当使用 Promise 调用时， use API 会集成 和 Suspense 错误边界。当传递给的 use Promise 处于挂起状态时，组件调用 use 将挂起。如果调用 use 的组件包装在 Suspense 边界中，则将显示回退。 解析 Promise 后，Suspense 回退将替换为使用 use API 返回的数据呈现的组件。如果传递给 use 的 Promise 被拒绝，则将显示最近的错误边界的回退。\r\n\r\n基础用法如下：\r\n\r\n```js\r\nconst value = use(resource);\r\n```\r\n\r\n**值得注意的是：**\r\n\r\n- use 必须在 Component 或 Hook 中调用 API。\r\n- 首选在服务器组件中创建 Promise 并将其传递给客户端组件，而不是在客户端组件中创建 Promise。在客户端组件中创建的 Promise 会在每次渲染时重新创建。从服务器组件传递到客户端组件的 promise 在重新渲染时是稳定的。\r\n- 像useContext一样， use(context)总是在调用它的组件上方寻找最接近的上下文提供程序。它会向上搜索，并且不考虑要从中调用 use(context) 的组件中的上下文提供程序。\r\n- 将 Promise 从服务器组件传递到客户端组件时，其解析值必须可序列化才能在服务器和客户端之间传递。函数等数据类型不可序列化，并且不能是此类 Promise 的解析值。\r\n\r\n在此项目中的使用如下：\r\n\r\n```jsx\r\n\"use client\";\r\nimport { Suspense } from \"react\";\r\nimport { GhostPointer } from \"./GhostPointer\";\r\nimport { MyTypeWrite } from \"./TypeWrite\";\r\nimport { DailyWord } from \"@/utils/getDailyWord\";\r\nimport ErrorBoundary from \"./ErrorBoundary\";\r\n\r\nexport function Banner({\r\n  language,\r\n  isGetDailyWord,\r\n  wordsFetch,\r\n}: {\r\n  wordsFetch?: Promise<DailyWord>;\r\n  language: string;\r\n  isGetDailyWord: boolean;\r\n}) {\r\n  return (\r\n    <ErrorBoundary\r\n      fallback={\r\n        <GhostPointer>\r\n          <span\r\n            style={{\r\n              display: \"flex\",\r\n              lineHeight: \"250px\",\r\n              fontSize: \"4rem\",\r\n              justifyContent: \"center\",\r\n              color: \"white\",\r\n            }}\r\n          >\r\n            ⚠️Something went wrong\r\n          </span>\r\n        </GhostPointer>\r\n      }\r\n    >\r\n      <Suspense\r\n        fallback={\r\n          <GhostPointer>\r\n            <span\r\n              style={{\r\n                display: \"flex\",\r\n                lineHeight: \"250px\",\r\n                fontSize: \"4rem\",\r\n                justifyContent: \"center\",\r\n                color: \"white\",\r\n              }}\r\n            >\r\n              Loading...\r\n            </span>\r\n          </GhostPointer>\r\n        }\r\n      >\r\n        <GhostPointer>\r\n          <MyTypeWrite\r\n            language={language}\r\n            wordsFetch={wordsFetch}\r\n            isGetDailyWord={isGetDailyWord}\r\n          />\r\n        </GhostPointer>\r\n      </Suspense>\r\n    </ErrorBoundary>\r\n  );\r\n}\r\n```\r\n\r\n利用ErrorBoundary以及Suspense包裹目标组件，在解析中以及解析失败后有相对应的UI呈现。\r\n再从服务端传入wordsFetch函数再进行use解析。\r\n\r\n```tsx\r\n//layout\r\nimport { Banner } from '../components/Banner';\r\nimport { getDailyWord } from '@/utils/getDailyWord';\r\n\r\nexport default async function FrontLayout({\r\n  children,\r\n  params: { language },\r\n}: {\r\n  children: React.ReactNode;\r\n  params: { language: string };\r\n}) {\r\n  const wordsFetch = getDailyWord();\r\n  return (\r\n    <div className=\"flex flex-col items-center\">\r\n      <div className=\"w-[100vw]\">\r\n        <Banner language={language} isGetDailyWord={true} wordsFetch={wordsFetch}></Banner>\r\n      </div>\r\n      <section className=\"w-full\">{children}</section>\r\n    </div>\r\n  );\r\n}\r\n//TypeWrite\r\n('use client');\r\nimport { usePathname } from 'next/navigation';\r\nimport { ReactTyped } from 'react-typed';\r\nimport { getDailyWord } from '@/utils/getDailyWord';\r\nimport { Suspense, use, useState } from 'react';\r\nimport { DailyWord } from '@/utils/getDailyWord';\r\nimport { splitPathname } from '@/utils/dealPathname';\r\nimport { useTranslation } from '@/app/i18n/client';\r\nexport function MyTypeWrite({\r\n  language,\r\n  isGetDailyWord,\r\n  wordsFetch,\r\n}: {\r\n  language: string;\r\n  isGetDailyWord: boolean;\r\n  wordsFetch?: Promise<DailyWord>;\r\n}) {\r\n  let word;\r\n  const pathName = usePathname();\r\n  const title = splitPathname(pathName);\r\n  const { t } = useTranslation(language, 'translations');\r\n  if (isGetDailyWord && wordsFetch) {\r\n    const words = use(wordsFetch);\r\n    word = language === 'zh-CN' ? words.note : words.content;\r\n  }\r\n  return (\r\n    <ReactTyped\r\n      strings={!word ? [t(title)] : [word]}\r\n      typeSpeed={50}\r\n      style={{\r\n        display: 'flex',\r\n        lineHeight: '250px',\r\n        fontSize: '4rem',\r\n        justifyContent: 'center',\r\n        color: 'white',\r\n      }}\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n最终效果可见博客首页(代码存放于github)\r\n\r\n### 其他\r\n\r\nReact19的更新远不止于此，目前我只用上这两个方法。\r\n\r\n还有关于乐观更新，表单操作等等的钩子尚未使用。\r\n\r\n以及令人诟病的Ref转发也得到了优化。\r\n\r\n报错提示更人性化等等等等。\r\n\r\n在未来会慢慢投入使用，投入生产。\r\n\r\n[React19官方博客](https://react.dev/blog/2024/04/25/react-19)\r\n\r\n[关于USE](https://react.dev/reference/react/use)\r\n\r\n[关于Compiler](https://react.dev/learn/react-compiler#)\r\n",
      "count": "4.9k",
      "readingTime": "25 ",
      "createdAt": "2024-11-08T15:07:01.000Z",
      "updatedAt": "2024-11-09T13:54:55.000Z",
      "modified": true
    }
  },
  "postDataList": [
    {
      "authors": [
        "yy"
      ],
      "title": "yyblog",
      "tag": "技术/react",
      "path": "yyblog",
      "rawFilePath": "./yyblog.md",
      "coverImage": "https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b76076eab124179816d68b846280cdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWVnYXRyb25LaW5n:q75.awebp?rk3s=f64ab15b&x-expires=1731736114&x-signature=3ggdE9od5WvMZaVJ7VFlQtt48rA%3D",
      "text": "原本，我利用 Hexo 搭建了一个个人博客，刚开始还挺新鲜的，但慢慢就觉得样式单调，而且我想加入评论以及流量监控很麻烦。所以想着要不自己手写一个，更好控制也能自定义样式。于是 yyblog 就孕育而生\r\n\r\n# 结构一点测试eeee\r\n\r\n整个博客，不仅仅由 yyblog 组成，还有 ybg-cli 脚手架，用于自动创建删除文章以及编译文章。\r\n![Minion](https://octodex.github.com/images/minion.png)\r\n\r\n```javascript\r\nconsole.log('Hello, world!');\r\n```\r\n\r\n- **yyblog**\r\n\r\n  - Nextjs\r\n  - typescript\r\n  - tailwind\r\n  - react-syntax-highlighter\r\n\r\n- **ybg-cli**\r\n  - cac\r\n  - gray-matter\r\n  - he\r\n\r\n## yyblog\r\n\r\n采用`Nextjs`+`Typescript`+`Tailwindw`为主要技术。\r\n\r\n<details>\r\n  <summary>点击展开更多信息</summary>\r\n  这是详细的内容，可以在点击时展开。\r\n</details>\r\n\r\n效仿 Hexo 采用纯前端，文章编写删除编译都在本地运行，对前端工程师更友好。\r\nNextjs 同时也支持全栈开发。简单的 sql 语句也能够对文章进行增删改查。\r\n\r\nNext 提供的文件路由同时也可以帮我们自定义一些特殊页面，常见的 layout 页面，404 页面以及错误页面等等。\r\n\r\n> 避免中文命名文件！！\r\n\r\n除了文件路由以外，Next 也提供了很多组件以及优化，比如 `font`，`<Image>`标签还有`<Script>`标签。\r\n这里说一下`<Script>`，博客网站上我放了一些动画(来源于 codepen),而这些动画`script`脚本，放入 `tsx(jsx)` 中只能通过`dangerouslySetInnerHTML`这个极具风险的 attribute\r\n但正好 Nextjs 提供了一个`<Script>`，能够让我们使用脚本组件。\r\n\r\n## ybg-cli\r\n\r\n采用纯前端的重点就在于文章的生成删除以及编译，麻烦就麻烦在编译成 TSX 代码插入到 yyblog 中形成页面。\r\n\r\n光看文字不如上点代码：\r\n\r\n```typescript\r\nexport async function compileFile(): Promise<mdFile[]> {\r\n  let compiledFiles: mdFile[] = [];\r\n  const fileList = fs.readdirSync(_postFolder);\r\n  for (const file of fileList) {\r\n    const filePath = path.join(_postFolder, file);\r\n    const fileContent = fs.readFileSync(filePath, 'utf-8');\r\n    const parsedFile = matter(fileContent);\r\n    const newMatter = {\r\n      ...parsedFile,\r\n      data: { ...parsedFile.data, date: UTCToString(parsedFile.data.date) },\r\n    };\r\n    const picPath = makeImportPic(await marked(parsedFile.content));\r\n    const htmlText = HtmlToNext(await marked(parsedFile.content));\r\n    compiledFiles.push(\r\n      picPath\r\n        ? {\r\n            mdMatter: newMatter,\r\n            mdHtml: htmlText,\r\n            other: {\r\n              picPath: picPath,\r\n            },\r\n          }\r\n        : { mdMatter: newMatter, mdHtml: htmlText },\r\n    );\r\n  }\r\n  return compiledFiles;\r\n}\r\n```\r\n\r\n读取文件并且用 gray-matter 解析 md 文件生成对应的内容。\r\n`mdMatter`是文章头部`yaml`格式内容的解析。\r\n`mdHtml`是文章主题部分的解析。\r\n`other`是解析成 Html 后需要插入到最后 TSX 内容的东西。\r\n\r\n重点在于`HtmlToNext`函数:\r\n\r\n```tsx\r\nimport he from 'he';\r\nfunction ImageRepimg(html: string) {\r\n  const processedHtml = html.replace(\r\n    /<img\\s+src=\"(.*?)\"\\s+alt=\"(.*?)\".*?\\/>/g,\r\n    function (match, src, alt) {\r\n      const modifiedSrc = src.split('/');\r\n      const newSrc = modifiedSrc[modifiedSrc.length - 1]; //修改后的SRC\r\n\r\n      const modifiedAlt = alt; // 修改后的alt\r\n\r\n      return `<Image src={${newSrc.slice(0, newSrc.lastIndexOf('.'))}} alt=\"${modifiedAlt}\" \r\n      sizes=\"100vw\"\r\n      style={{\r\n        width: '100%',\r\n        height: 'auto',\r\n      }} />`;\r\n    },\r\n  );\r\n  return processedHtml;\r\n}\r\nfunction replaceClassName(html: string) {\r\n  const processedHtml = html.replace(/class=/g, 'className=');\r\n  return processedHtml;\r\n}\r\nfunction highLightHtml(html: string) {\r\n  // 在代码块内的特殊字符前加上 \\\r\n  const replacedString1 = html.replace(\r\n    /<pre><code className=\"language-(\\w+)\">([\\s\\S]*?)<\\/code><\\/pre>/g,\r\n    (_, language, codeContent) => {\r\n      //转义符删除\r\n      const decodeCode = he.decode(codeContent);\r\n      const codeWithBackslash = decodeCode.replace(/([^\\w\\s\"'])/g, '\\\\$1');\r\n      return `<SyntaxHighlighter language=\"${language}\" style={oneLight} showLineNumbers>{ \\`${codeWithBackslash}\\` }</SyntaxHighlighter>`;\r\n    },\r\n  );\r\n\r\n  return replacedString1;\r\n}\r\nexport function HtmlToNext(html: string) {\r\n  //替换img标签\r\n  const step1Html = ImageRepimg(html);\r\n  //替换class为className\r\n  const step2Html = replaceClassName(step1Html);\r\n  //高亮代码\r\n  const step3Html = highLightHtml(step2Html);\r\n  //闭合分割线\r\n  const step4Html = step3Html.replace(/<hr>/g, '<hr />');\r\n  return step4Html;\r\n}\r\n```\r\n\r\n通过对解析后 html 的修改，主要是用正则，实现 html 向 TSX(Next)的转化。\r\n\r\n# 3月4号更新：\r\n\r\n更新了英文版，主要采用的是Next的中间件-`middleware.js`以及`react-i18next`和`i18next`,这两个库i18n转化库。\r\n\r\n配置的教程在[这里](https://locize.com/blog/next-app-dir-i18n/)\r\n\r\n```javascript\r\nimport { NextResponse } from 'next/server';\r\nimport acceptLanguage from 'accept-language';\r\nimport { fallbackLng, languages, cookieName } from '@/app/i18n/setting';\r\n\r\nacceptLanguage.languages(languages);\r\n\r\nexport const config = {\r\n  // matcher: '/:lng*'\r\n  matcher: ['/((?!api|_next/static|_next/image|imgs|favicon.ico|sw.js).*)'],\r\n};\r\nexport function middleware(req) {\r\n  let lng;\r\n  if (req.cookies.has(cookieName)) lng = acceptLanguage.get(req.cookies.get(cookieName).value);\r\n  if (!lng) lng = acceptLanguage.get(req.headers.get('Accept-Language'));\r\n  if (!lng) lng = fallbackLng;\r\n\r\n  // Redirect if lng in path is not supported\r\n\r\n  if (\r\n    !languages.some((loc) => req.nextUrl.pathname.startsWith(`/${loc}`)) &&\r\n    !req.nextUrl.pathname.startsWith('/_next')\r\n  ) {\r\n    return NextResponse.redirect(new URL(`/${lng}${req.nextUrl.pathname}`, req.url));\r\n  }\r\n  if (req.headers.has('referer')) {\r\n    const refererUrl = new URL(req.headers.get('referer'));\r\n    const lngInReferer = languages.find((l) => refererUrl.pathname.startsWith(`/${l}`));\r\n    const response = NextResponse.next();\r\n    if (lngInReferer) response.cookies.set(cookieName, lngInReferer);\r\n    return response;\r\n  }\r\n\r\n  return NextResponse.next();\r\n}\r\n```\r\n\r\n这一段是中间件主要的代码，作用是用户使用不支持语言时自动跳转到默认语言，记住用户每次结束后使用的语言。\r\n\r\n**注意:**\r\n\r\n```js\r\nexport const config = {\r\n  // matcher: '/:lng*'\r\n  matcher: ['/((?!api|_next/static|_next/image|imgs|favicon.ico|sw.js).*)'],\r\n};\r\n```\r\n\r\n`matcher`匹配器用于使得中间件在特定的路径上执行。\r\n这个字符串是负向预测先行，用于匹配不包含以上内容的字符串片段，你需要稍微修改正则以匹配你的文件目录。\r\n\r\n# 3月24号更新：\r\n\r\n**一键部署**\r\n\r\n选择一个静态页面管理网站，比如githubpage或者vercrel，绑定自己的博客仓库。\r\n在根目录下设置`_blog.json`,配置文件：\r\n\r\n```json\r\n{\r\n  \"deployCon\": {\r\n    \"commitMessage\": \"docs: new essay\", //每次commit的message\r\n    \"remote_store_url\": \"https://github.com/YYGod0120/yyblog.git\", //远程仓库url\r\n    \"remote_store_name\": \"origin\", //别名\r\n    \"branch\": \"main\" //想要提交的分支\r\n  }\r\n}\r\n```\r\n\r\n然后使用`ybg init`进行初始化。\r\n最后每次写完文章执行`pnpm d`进行部署。\r\n\r\n# 附件\r\n\r\n> 一些使用到的库或者代码：\r\n\r\n- [gray-matter](https://github.com/jonschlinkert/gray-matter)：解析静态网页元数据\r\n- [marked](https://github.com/markedjs/marked)：转化`md`文件为 HTML\r\n- [rimraf](https://github.com/isaacs/rimraf)：快捷删除文件夹及其内容\r\n- [tsup](https://github.com/egoist/tsup)：快速构建 TypeScript 项目的工具\r\n- [picocolors](https://github.com/alexeyraspopov/picocolors)：命令行颜色\r\n- [cac](https://github.com/cacjs/cac)：构建命令行工具的 JavaScript/TypeScript 框架\r\n- [codepen](https://codepen.io/)： 动画及特别的 404 页面都来源于此\r\n- [react-i18next](https://github.com/i18next/react-i18next) i18n for react\r\n",
      "count": "5.3k",
      "readingTime": "26 ",
      "createdAt": "2024-11-08T15:07:01.000Z",
      "updatedAt": "2024-11-09T13:41:44.000Z",
      "modified": true
    },
    {
      "authors": [
        "yy"
      ],
      "title": "react19",
      "tag": "随笔/生活",
      "path": "react19",
      "rawFilePath": "./react19.md",
      "summary": "这篇文章记录了react19相关的一些内容",
      "coverImage": "https://p6-xtjj-sign.byteimg.com/tos-cn-i-73owjymdk6/0b76076eab124179816d68b846280cdc~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgTWVnYXRyb25LaW5n:q75.awebp?rk3s=f64ab15b&x-expires=1731736114&x-signature=3ggdE9od5WvMZaVJ7VFlQtt48rA%3D",
      "text": "# React19qqqq31231\r\n\r\n4月25日，React官方宣布React19在NPM上推出，可以先行下载使用。\r\n正好此博客也是NextJS搭建的，尝试一下React19带来哪些变化。\r\n\r\n## 准备测试修改\r\n\r\n官方的建议是先安装稳定版本的React18.3,以在更新到19前发现一些潜藏的问题。\r\n检查无误后，就可以安装React-19（还处于BETA）使用新API。\r\n[React-v19的升级指南](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#typescript-changes)\r\n\r\n## 变化\r\n\r\nReact在沉寂一长段时间后，听取社区的意见，改掉许多开发痛点以及优化框架。重磅推出了React19\r\n\r\n**重大的改变有以下几点：**\r\n\r\n- React-Compiler：帮助开发人员自动优化页面，减少甚至抛弃useMemo和useCallback。\r\n- Actions：新的`<form>`标签以及配套的Hooks表单操作。\r\n- New Hooks：新的增强操作钩子如`use()`等等。\r\n- Document Metadata：现在可以直接在单个组件里编写Meta数据。\r\n- Web components：React 代码现在将使我们能够合并 Web 组件。\r\n\r\n### React-Compiler\r\n\r\nReactCompiler可以说是19里最让人激动的东西，它是一个新的编译器，用于帮程序员优化React代码。\r\n比如说先前的useMemo，useCallback等等这一系列的优化钩子，不说使用起来麻烦，使用不当甚至还会造成负优化。于是React推出了Compiler直接自动处理代码，避免了负优化的现象。\r\n\r\n简单来说，Compiler做到的事情就是将组件中每个元素，每一个函数都进行缓存，只有当发生变化的时候才会重新缓存，不然就接着使用。\r\n本文主要是说使用而非原理，具体可以查看这篇文章[我已彻底拿捏 React Compiler](https://mp.weixin.qq.com/s/7XFn56O3ia5vHPqSaeo6GA)\r\n\r\n对于React-Compiler的启用，我们首先要对我们的项目做一个检测。\r\n\r\n```shell\r\nnpx react-compiler-healthcheck\r\n```\r\n\r\n> 该脚本主要用于检测\r\n> 1、项目中有多少组件可以成功优化：越多越好\r\n> 2、是否使用严格模式，使用了优化成功率更高\r\n> 3、是否使用了与 Compiler 不兼容的三方库\r\n\r\n这个框架的检测效果如下：\r\n<img src=\"/imgs/React19-BETA/test.png\" alt=\"react-server-components\"  />\r\n对于不同的框架使用Compiler的方法不同，Next启用Compiler需要先下载Next-canary版以及babel-plugin-react-compiler\r\n\r\n```shell\r\nnpm install next@canary babel-plugin-react-compiler\r\n```\r\n\r\n然后在`next.config.js`:\r\n\r\n```js\r\n// next.config.js\r\n/** @type {import('next').NextConfig} */\r\nconst nextConfig = {\r\n  experimental: {\r\n    reactCompiler: true,\r\n  },\r\n};\r\n\r\nmodule.exports = nextConfig;\r\n```\r\n\r\n便可以启动compiler对项目进行优化。\r\n成功优化后，可以在React-dev-tool就会看到Memo星星。\r\n<img src=\"/imgs/React19-BETA/compiler.png\" alt=\"react-server-components\"/>\r\n\r\n> 值得一说的是Compiler还在测试中，存在不少问题，比如与i18n的客户端组件存在一些冲突等，所以有待观望\r\n\r\n### New Hooks\r\n\r\nReact19更新许多新的Hooks，包括`use()`,`useOptimistic()`,`useFormStatus()`,绝大多是都是为了Action也就是`<form>`标签所适配的。\r\n\r\n因为没用到表单，所以我只先使用`use()`。\r\n\r\nuse用于获取资源的值，比如说Promise或者Context。和其他钩子不同，它可以在if语句中使用。\r\n\r\n他的具体原理如下(取自官方文档)：\r\n\r\n> 当使用 Promise 调用时， use API 会集成 和 Suspense 错误边界。当传递给的 use Promise 处于挂起状态时，组件调用 use 将挂起。如果调用 use 的组件包装在 Suspense 边界中，则将显示回退。 解析 Promise 后，Suspense 回退将替换为使用 use API 返回的数据呈现的组件。如果传递给 use 的 Promise 被拒绝，则将显示最近的错误边界的回退。\r\n\r\n基础用法如下：\r\n\r\n```js\r\nconst value = use(resource);\r\n```\r\n\r\n**值得注意的是：**\r\n\r\n- use 必须在 Component 或 Hook 中调用 API。\r\n- 首选在服务器组件中创建 Promise 并将其传递给客户端组件，而不是在客户端组件中创建 Promise。在客户端组件中创建的 Promise 会在每次渲染时重新创建。从服务器组件传递到客户端组件的 promise 在重新渲染时是稳定的。\r\n- 像useContext一样， use(context)总是在调用它的组件上方寻找最接近的上下文提供程序。它会向上搜索，并且不考虑要从中调用 use(context) 的组件中的上下文提供程序。\r\n- 将 Promise 从服务器组件传递到客户端组件时，其解析值必须可序列化才能在服务器和客户端之间传递。函数等数据类型不可序列化，并且不能是此类 Promise 的解析值。\r\n\r\n在此项目中的使用如下：\r\n\r\n```jsx\r\n\"use client\";\r\nimport { Suspense } from \"react\";\r\nimport { GhostPointer } from \"./GhostPointer\";\r\nimport { MyTypeWrite } from \"./TypeWrite\";\r\nimport { DailyWord } from \"@/utils/getDailyWord\";\r\nimport ErrorBoundary from \"./ErrorBoundary\";\r\n\r\nexport function Banner({\r\n  language,\r\n  isGetDailyWord,\r\n  wordsFetch,\r\n}: {\r\n  wordsFetch?: Promise<DailyWord>;\r\n  language: string;\r\n  isGetDailyWord: boolean;\r\n}) {\r\n  return (\r\n    <ErrorBoundary\r\n      fallback={\r\n        <GhostPointer>\r\n          <span\r\n            style={{\r\n              display: \"flex\",\r\n              lineHeight: \"250px\",\r\n              fontSize: \"4rem\",\r\n              justifyContent: \"center\",\r\n              color: \"white\",\r\n            }}\r\n          >\r\n            ⚠️Something went wrong\r\n          </span>\r\n        </GhostPointer>\r\n      }\r\n    >\r\n      <Suspense\r\n        fallback={\r\n          <GhostPointer>\r\n            <span\r\n              style={{\r\n                display: \"flex\",\r\n                lineHeight: \"250px\",\r\n                fontSize: \"4rem\",\r\n                justifyContent: \"center\",\r\n                color: \"white\",\r\n              }}\r\n            >\r\n              Loading...\r\n            </span>\r\n          </GhostPointer>\r\n        }\r\n      >\r\n        <GhostPointer>\r\n          <MyTypeWrite\r\n            language={language}\r\n            wordsFetch={wordsFetch}\r\n            isGetDailyWord={isGetDailyWord}\r\n          />\r\n        </GhostPointer>\r\n      </Suspense>\r\n    </ErrorBoundary>\r\n  );\r\n}\r\n```\r\n\r\n利用ErrorBoundary以及Suspense包裹目标组件，在解析中以及解析失败后有相对应的UI呈现。\r\n再从服务端传入wordsFetch函数再进行use解析。\r\n\r\n```tsx\r\n//layout\r\nimport { Banner } from '../components/Banner';\r\nimport { getDailyWord } from '@/utils/getDailyWord';\r\n\r\nexport default async function FrontLayout({\r\n  children,\r\n  params: { language },\r\n}: {\r\n  children: React.ReactNode;\r\n  params: { language: string };\r\n}) {\r\n  const wordsFetch = getDailyWord();\r\n  return (\r\n    <div className=\"flex flex-col items-center\">\r\n      <div className=\"w-[100vw]\">\r\n        <Banner language={language} isGetDailyWord={true} wordsFetch={wordsFetch}></Banner>\r\n      </div>\r\n      <section className=\"w-full\">{children}</section>\r\n    </div>\r\n  );\r\n}\r\n//TypeWrite\r\n('use client');\r\nimport { usePathname } from 'next/navigation';\r\nimport { ReactTyped } from 'react-typed';\r\nimport { getDailyWord } from '@/utils/getDailyWord';\r\nimport { Suspense, use, useState } from 'react';\r\nimport { DailyWord } from '@/utils/getDailyWord';\r\nimport { splitPathname } from '@/utils/dealPathname';\r\nimport { useTranslation } from '@/app/i18n/client';\r\nexport function MyTypeWrite({\r\n  language,\r\n  isGetDailyWord,\r\n  wordsFetch,\r\n}: {\r\n  language: string;\r\n  isGetDailyWord: boolean;\r\n  wordsFetch?: Promise<DailyWord>;\r\n}) {\r\n  let word;\r\n  const pathName = usePathname();\r\n  const title = splitPathname(pathName);\r\n  const { t } = useTranslation(language, 'translations');\r\n  if (isGetDailyWord && wordsFetch) {\r\n    const words = use(wordsFetch);\r\n    word = language === 'zh-CN' ? words.note : words.content;\r\n  }\r\n  return (\r\n    <ReactTyped\r\n      strings={!word ? [t(title)] : [word]}\r\n      typeSpeed={50}\r\n      style={{\r\n        display: 'flex',\r\n        lineHeight: '250px',\r\n        fontSize: '4rem',\r\n        justifyContent: 'center',\r\n        color: 'white',\r\n      }}\r\n    />\r\n  );\r\n}\r\n```\r\n\r\n最终效果可见博客首页(代码存放于github)\r\n\r\n### 其他\r\n\r\nReact19的更新远不止于此，目前我只用上这两个方法。\r\n\r\n还有关于乐观更新，表单操作等等的钩子尚未使用。\r\n\r\n以及令人诟病的Ref转发也得到了优化。\r\n\r\n报错提示更人性化等等等等。\r\n\r\n在未来会慢慢投入使用，投入生产。\r\n\r\n[React19官方博客](https://react.dev/blog/2024/04/25/react-19)\r\n\r\n[关于USE](https://react.dev/reference/react/use)\r\n\r\n[关于Compiler](https://react.dev/learn/react-compiler#)\r\n",
      "count": "4.9k",
      "readingTime": "25 ",
      "createdAt": "2024-11-08T15:07:01.000Z",
      "updatedAt": "2024-11-09T13:54:55.000Z",
      "modified": true
    }
  ]
}